---
phase: 08-review-workflows-and-attention-signals
plan: 02
type: execute
wave: 2
depends_on: [08-01]
files_modified:
  - internal/adapter/driven/github/client.go
  - internal/adapter/driven/github/writer.go
  - internal/application/pollservice.go
  - cmd/mygitpanel/main.go
  - internal/adapter/driving/web/handler.go
  - internal/adapter/driving/web/routes.go
  - internal/adapter/driving/web/viewmodel.go
  - internal/adapter/driving/web/viewmodel/viewmodel.go
  - internal/adapter/driving/web/templates/layout.templ
  - internal/adapter/driving/web/templates/components/settings_drawer.templ
  - internal/adapter/driving/web/static/js/stores.js
autonomous: true
requirements: [CRED-01, CRED-02]

must_haves:
  truths:
    - "Settings gear icon in sidebar opens the slide-in drawer without a page reload"
    - "User can enter a GitHub token in the settings drawer, click Save, and see 'GitHub token: configured' inline"
    - "User can enter an invalid token and see an error message inline without the drawer closing"
    - "PollService reads the token from CredentialStore at each poll cycle; env var token is the fallback/seed"
    - "If no token exists anywhere, polling is skipped but the app starts and the GUI is accessible"
    - "Jira credential fields (URL, email, token) are rendered in the drawer but do nothing beyond storing to DB"
    - "Drawer closes on backdrop click; all Alpine state (open/closed, section) survives HTMX morph swaps"
  artifacts:
    - path: "internal/adapter/driven/github/writer.go"
      provides: "GitHubWriter implementation on the existing Client struct (ValidateToken only at this stage)"
      contains: "func (c *Client) ValidateToken"
    - path: "internal/adapter/driving/web/templates/components/settings_drawer.templ"
      provides: "Slide-in settings drawer with credential form sections"
      contains: "settings_drawer"
    - path: "internal/adapter/driving/web/static/js/stores.js"
      provides: "Alpine drawer store added to existing stores.js"
      contains: "Alpine.store('drawer'"
    - path: "internal/adapter/driving/web/handler.go"
      provides: "SaveGitHubCredentials and SaveJiraCredentials handlers"
      contains: "SaveGitHubCredentials"
    - path: "internal/application/pollservice.go"
      provides: "PollService reads token from CredentialStore each cycle (env var as fallback)"
      contains: "CredentialStore"
  key_links:
    - from: "internal/adapter/driving/web/templates/components/settings_drawer.templ"
      to: "/app/settings/github"
      via: "hx-post form; response swaps #cred-github-status"
      pattern: "hx-post.*settings/github"
    - from: "internal/application/pollservice.go"
      to: "internal/domain/port/driven/credentialstore.go"
      via: "credStore.Get(ctx, 'github_token') called at start of each poll cycle"
      pattern: "credStore\\.Get.*github_token"
    - from: "cmd/mygitpanel/main.go"
      to: "internal/adapter/driven/sqlite/credentialrepo.go"
      via: "NewCredentialRepo(db, cfg.SecretKey) injected into PollService and WebHandler"
      pattern: "NewCredentialRepo"
---

<objective>
Implement the settings drawer UI and wire credential management end-to-end: GitHub token entry with immediate validation, Jira credential fields (stored, not yet functional), hot-swap token reading in PollService, and the GitHubWriter ValidateToken implementation.

Purpose: This plan delivers CRED-01 and CRED-02 fully — the user can configure credentials through the GUI and polling picks them up without a restart.

Output: Slide-in Alpine.js settings drawer rendered in the layout, POST handlers for saving credentials, ValidateToken implementation, and PollService refactored to read the token from CredentialStore on each cycle.
</objective>

<execution_context>
@/home/ericfisher/.claude/get-shit-done/workflows/execute-plan.md
@/home/ericfisher/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-review-workflows-and-attention-signals/08-CONTEXT.md
@.planning/phases/08-review-workflows-and-attention-signals/08-RESEARCH.md
@.planning/phases/08-review-workflows-and-attention-signals/08-01-SUMMARY.md
@internal/adapter/driven/github/client.go
@internal/adapter/driven/github/graphql.go
@internal/application/pollservice.go
@internal/adapter/driving/web/handler.go
@internal/adapter/driving/web/routes.go
@internal/adapter/driving/web/static/js/stores.js
@internal/adapter/driving/web/templates/layout.templ
@internal/adapter/driving/web/templates/components/sidebar.templ
@cmd/mygitpanel/main.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: GitHubWriter ValidateToken, PollService hot-swap, and composition root wiring</name>
  <files>
    internal/adapter/driven/github/writer.go
    internal/application/pollservice.go
    cmd/mygitpanel/main.go
  </files>
  <action>
    **internal/adapter/driven/github/writer.go:**
    Create a new file (not modifying client.go). Declare the compile-time check
    `var _ driven.GitHubWriter = (*Client)(nil)` here — this will fail to compile
    until all GitHubWriter methods are implemented. For this plan, only ValidateToken
    is implemented; stub the remaining five methods with `return fmt.Errorf("not yet implemented")`.
    This unblocks the web handler wiring while Plans 03 and 04 add real implementations.

    ValidateToken implementation:
    ```go
    func (c *Client) ValidateToken(ctx context.Context, token string) (string, error) {
        // Create a one-shot client with a timeout to avoid hanging on slow API responses.
        httpClient := &http.Client{Timeout: 10 * time.Second}
        tempClient := gh.NewClient(httpClient).WithAuthToken(token)
        user, _, err := tempClient.Users.Get(ctx, "")
        if err != nil {
            return "", fmt.Errorf("token validation failed: %w", err)
        }
        return user.GetLogin(), nil
    }
    ```
    Import `net/http`, `time`, and `gh "github.com/google/go-github/v82/github"`.

    **internal/application/pollservice.go:**
    Add `tokenProvider func(ctx context.Context) (string, error)` and
    `clientFactory func(token string) driven.GitHubClient` fields to PollService.
    Both are optional (may be nil). Use the TokenProvider closure approach — this
    avoids any import cycle between application and adapter layers, and is concurrency-safe
    because both callers (pollAll, pollDueRepos) run exclusively in the single poll
    goroutine started by Start, so no mutex is needed on s.ghClient.

    Add a `maybeRefreshToken` helper called at the top of each poll cycle:
    ```go
    // maybeRefreshToken re-reads the token from the credential store and hot-swaps
    // the GitHub client if a new non-empty token is found. Safe: only called from
    // the single poll goroutine — no concurrent access to s.ghClient.
    func (s *PollService) maybeRefreshToken(ctx context.Context) {
        if s.tokenProvider == nil || s.clientFactory == nil {
            return
        }
        token, err := s.tokenProvider(ctx)
        if err != nil || token == "" {
            return
        }
        s.ghClient = s.clientFactory(token)
    }
    ```

    Inject from main.go as closures so the application layer has no adapter import:
    ```go
    tokenProvider: func(ctx context.Context) (string, error) {
        return credStore.Get(ctx, "github_token")
    },
    clientFactory: func(token string) driven.GitHubClient {
        return githubadapter.NewClient(token, cfg.GitHubUsername)
    },
    ```

    **cmd/mygitpanel/main.go:**
    After step 5 (wire adapters), add:
    ```go
    credStore := sqliteadapter.NewCredentialRepo(db, cfg.SecretKey)
    thresholdStore := sqliteadapter.NewThresholdRepo(db)
    ignoreStore := sqliteadapter.NewIgnoreRepo(db)
    ```
    Pass credStore to NewPollService (new last argument).
    Create githubWriter: the existing ghClient already implements GitHubWriter after
    writer.go is added — no new constructor needed, just use `ghClient` where a
    driven.GitHubWriter is needed.
    Update NewHandler call to pass credStore, thresholdStore, ignoreStore, and
    githubWriter (as driven.GitHubWriter) — web Handler struct will accept these
    in Task 2.
  </action>
  <verify>
    go build ./... succeeds (stubs satisfy the GitHubWriter interface)
    go test ./internal/application/... passes
  </verify>
  <done>
    Client implements GitHubWriter (with stubs for unimplemented methods). PollService
    re-reads token from CredentialStore each cycle. Composition root wires all new stores.
  </done>
</task>

<task type="auto">
  <name>Task 2: Settings drawer UI — Alpine store, templ component, handlers, routes</name>
  <files>
    internal/adapter/driving/web/handler.go
    internal/adapter/driving/web/routes.go
    internal/adapter/driving/web/viewmodel.go
    internal/adapter/driving/web/viewmodel/viewmodel.go
    internal/adapter/driving/web/templates/layout.templ
    internal/adapter/driving/web/templates/components/settings_drawer.templ
    internal/adapter/driving/web/static/js/stores.js
  </files>
  <action>
    **internal/adapter/driving/web/static/js/stores.js — add drawer store:**
    Add to the existing alpine:init listener block (after the theme store):
    ```javascript
    Alpine.store('drawer', {
        open: false,
        section: 'credentials',
        show(section) { this.section = section || 'credentials'; this.open = true; },
        hide() { this.open = false; }
    });
    ```

    **internal/adapter/driving/web/templates/components/settings_drawer.templ:**
    Render a fixed-position slide-in drawer following the pattern from 08-RESEARCH.md
    Section 4.1. The drawer is always present in the DOM (rendered in layout, not
    in any HTMX swap target) and controlled entirely by Alpine $store.drawer state.

    Structure:
    1. Backdrop: fixed inset-0 bg-black/40 z-40 with x-show="$store.drawer.open",
       x-transition (opacity 0→100), @click="$store.drawer.hide()".
    2. Panel: fixed right-0 top-0 h-full w-96 bg-white dark:bg-gray-800 shadow-xl z-50
       overflow-y-auto with x-show="$store.drawer.open",
       x-transition (translate-x-full → translate-x-0 on enter).
    3. Panel header: "Settings" title + close button (X icon, @click="$store.drawer.hide()").
    4. Sections nav: two tabs — "Credentials" and "Thresholds" —
       @click="$store.drawer.section = 'credentials'" etc.,
       active style: border-b-2 border-indigo-500.
    5. Credentials section (x-show="$store.drawer.section === 'credentials'"):
       - GitHub subsection:
         - Header: "GitHub"
         - Token input (type="password", name="github_token", placeholder="ghp_...")
         - Username input (name="github_username")
         - Save button with hx-post="/app/settings/github", hx-target="#cred-github-status",
           hx-swap="innerHTML", hx-indicator="#cred-github-spinner"
         - Spinner span id="cred-github-spinner" class="htmx-indicator" (SVG spinner)
         - Status div id="cred-github-status" (empty initially)
       - Jira subsection (same pattern):
         - Header: "Jira" with "(Phase 9)" label
         - URL input (name="jira_url")
         - Email input (name="jira_email")
         - Token input (type="password", name="jira_token")
         - Save button hx-post="/app/settings/jira", hx-target="#cred-jira-status"
         - Status div id="cred-jira-status"
    6. Thresholds section (x-show="$store.drawer.section === 'thresholds'"):
       Placeholder for Plan 05: `<p class="text-gray-500 text-sm">Threshold configuration coming in a later step.</p>`

    **internal/adapter/driving/web/templates/layout.templ:**
    Add `@components.SettingsDrawer()` call just before the closing </body> tag, after
    the `@contents` call. Import the components package. The drawer must be OUTSIDE
    any HTMX swap target to preserve Alpine state across partial refreshes.

    **internal/adapter/driving/web/viewmodel/viewmodel.go:**
    Add CredentialStatusViewModel struct for handler responses:
    ```go
    type CredentialStatusViewModel struct {
        Success  bool
        Message  string
        Username string // populated on successful GitHub token validation
    }
    ```

    **internal/adapter/driving/web/handler.go:**
    Add four new fields to the Handler struct:
    ```go
    credStore     driven.CredentialStore
    thresholdStore driven.ThresholdStore
    ignoreStore    driven.IgnoreStore
    ghWriter      driven.GitHubWriter
    ```
    Update NewHandler to accept and store these four additional parameters.

    Add SaveGitHubCredentials handler (POST /app/settings/github):
    - Parse form: github_token, github_username
    - If ErrEncryptionKeyNotSet: render error fragment "Credential storage requires MYGITPANEL_SECRET_KEY to be set"
    - Call h.ghWriter.ValidateToken(r.Context(), token) — if error: render error fragment with the error message
    - On success: call h.credStore.Set(ctx, "github_token", token) and h.credStore.Set(ctx, "github_username", username)
    - Render success fragment: `<span class="text-green-600 text-sm">GitHub token: configured (username)</span>`
    - Render error fragment: `<span class="text-red-600 text-sm">Error: {message}</span>`
    - Both fragments are written directly as templ components or plain HTML via fmt.Fprintf

    Add SaveJiraCredentials handler (POST /app/settings/jira):
    - Parse form: jira_url, jira_email, jira_token
    - Store all three in credStore using keys "jira_url", "jira_email", "jira_token"
    - No validation (Phase 9 will add Jira-specific validation)
    - Render success fragment: `<span class="text-green-600 text-sm">Jira credentials saved</span>`

    **internal/adapter/driving/web/routes.go:**
    Add two new routes:
    ```go
    mux.HandleFunc("POST /app/settings/github", h.SaveGitHubCredentials)
    mux.HandleFunc("POST /app/settings/jira", h.SaveJiraCredentials)
    ```

    Add settings gear icon button to the sidebar header in
    internal/adapter/driving/web/templates/components/sidebar.templ:
    An SVG gear icon button at the top-right of the sidebar header area:
    `@click="$store.drawer.show('credentials')"` — small, icon-only, no text label.

    Run `templ generate` after all .templ files are updated.
  </action>
  <verify>
    templ generate succeeds (no compile errors in .templ files)
    go build ./... succeeds
    go test ./... passes
    Manual: start server, open http://localhost:8080/, click gear icon — drawer slides in from right
    Manual: enter a valid GitHub token, click Save — drawer shows "GitHub token: configured (username)"
    Manual: enter an invalid token — drawer shows inline error, remains open
    Manual: click backdrop — drawer closes
    Manual: open PR detail (HTMX swap) — drawer state (open/closed) is preserved
  </verify>
  <done>
    Settings drawer renders in layout (outside swap targets). Credential forms submit
    via HTMX with inline success/error feedback. GitHub token validated before storing.
    Jira fields stored without validation. PollService uses DB token from next cycle onward.
  </done>
</task>

</tasks>

<verification>
1. go build ./... succeeds
2. go test ./... passes
3. templ generate produces no errors
4. GET / → gear icon visible in sidebar header
5. Clicking gear icon opens drawer without full page reload
6. POST /app/settings/github with valid token → "GitHub token: configured" status shown
7. POST /app/settings/github with invalid token → error message shown, drawer stays open
8. POST /app/settings/jira → "Jira credentials saved" shown
9. PollService: if DB token exists, it is used on the next poll cycle (verify via log output)
</verification>

<success_criteria>
- CRED-01: User can enter GitHub token and username in the settings drawer (plus Jira fields)
- CRED-02: Token is validated on save, stored encrypted in SQLite, used by PollService without restart
- Drawer is controlled by Alpine store — survives HTMX morph swaps
- All tests pass; go build succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/08-review-workflows-and-attention-signals/08-02-SUMMARY.md`
</output>
