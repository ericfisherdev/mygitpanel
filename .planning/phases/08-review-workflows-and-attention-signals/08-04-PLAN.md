---
phase: 08-review-workflows-and-attention-signals
plan: 04
type: execute
wave: 3
depends_on: [08-01, 08-02]
files_modified:
  - internal/adapter/driven/github/writer.go
  - internal/adapter/driven/github/graphql.go
  - internal/adapter/driving/web/handler.go
  - internal/adapter/driving/web/routes.go
  - internal/adapter/driving/web/viewmodel/viewmodel.go
  - internal/adapter/driving/web/templates/components/pr_detail.templ
autonomous: true
requirements: [REV-04]

must_haves:
  truths:
    - "PR detail view shows a draft toggle button only when the PR is authored by the authenticated user"
    - "Clicking the toggle sends one request; the button shows a loading state during the API call"
    - "After the API call succeeds, the PR header area morphs to reflect the new draft status"
    - "Toggling a ready-for-review PR to draft shows the Draft badge; toggling a draft PR shows the Ready badge"
    - "If the API call fails (e.g. not PR author, GraphQL error), an error message is shown inline"
  artifacts:
    - path: "internal/adapter/driven/github/graphql.go"
      provides: "ConvertPullRequestToDraft and MarkPullRequestReadyForReview GraphQL mutations"
      contains: "convertToDraftMutation"
    - path: "internal/adapter/driven/github/writer.go"
      provides: "ConvertPullRequestToDraft and MarkPullRequestReadyForReview implemented (stubs replaced)"
      contains: "func (c *Client) ConvertPullRequestToDraft"
    - path: "internal/adapter/driving/web/handler.go"
      provides: "ToggleDraftStatus handler"
      contains: "ToggleDraftStatus"
    - path: "internal/adapter/driving/web/templates/components/pr_detail.templ"
      provides: "Draft toggle button visible only on own PRs with loading state"
      contains: "ToggleDraft"
  key_links:
    - from: "internal/adapter/driving/web/templates/components/pr_detail.templ"
      to: "/app/prs/{owner}/{repo}/{number}/draft-toggle"
      via: "hx-post; response morphs #pr-detail-header"
      pattern: "draft-toggle"
    - from: "internal/adapter/driven/github/writer.go"
      to: "internal/adapter/driven/github/graphql.go"
      via: "c.executeDraftMutation(ctx, mutationString, nodeID)"
      pattern: "executeDraftMutation"
    - from: "internal/adapter/driven/github/writer.go"
      to: "github.com/google/go-github/v82/github PullRequests.Get"
      via: "fetch node_id on-demand via REST at toggle time"
      pattern: "PullRequests\\.Get.*nodeID|GetNodeID"
---

<objective>
Implement draft status toggling for the authenticated user's own PRs using GraphQL mutations. The existing hand-rolled GraphQL client in graphql.go is extended with two new mutations. The toggle button is only shown on PRs where pr.Author == authenticatedUser.

Purpose: Delivers REV-04 — user can convert their own PR between draft and ready-for-review without leaving the dashboard.

Output: Two GraphQL draft mutations in graphql.go, ConvertPullRequestToDraft and MarkPullRequestReadyForReview implemented in writer.go (replacing stubs), a ToggleDraftStatus web handler, and the draft toggle button in the PR detail header.
</objective>

<execution_context>
@/home/ericfisher/.claude/get-shit-done/workflows/execute-plan.md
@/home/ericfisher/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-review-workflows-and-attention-signals/08-CONTEXT.md
@.planning/phases/08-review-workflows-and-attention-signals/08-RESEARCH.md
@.planning/phases/08-review-workflows-and-attention-signals/08-02-SUMMARY.md
@internal/adapter/driven/github/graphql.go
@internal/adapter/driven/github/writer.go
@internal/adapter/driven/github/client.go
@internal/adapter/driving/web/handler.go
@internal/adapter/driving/web/templates/components/pr_detail.templ
@internal/adapter/driving/web/viewmodel/viewmodel.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: GraphQL draft mutations and writer.go implementation</name>
  <files>
    internal/adapter/driven/github/graphql.go
    internal/adapter/driven/github/writer.go
  </files>
  <action>
    **internal/adapter/driven/github/graphql.go — add two mutation strings and a shared executor:**

    Add three new unexported constants/variables after the existing threadResolutionQuery:
    ```go
    const convertToDraftMutation = `
    mutation ConvertToDraft($pullRequestId: ID!) {
        convertPullRequestToDraft(input: { pullRequestId: $pullRequestId }) {
            pullRequest { isDraft }
        }
    }`

    const markReadyMutation = `
    mutation MarkReady($pullRequestId: ID!) {
        markPullRequestReadyForReview(input: { pullRequestId: $pullRequestId }) {
            pullRequest { isDraft }
        }
    }`
    ```

    IMPORTANT: The research notes LOW confidence on whether the variable name is
    `pullRequestId` or `id`. Verify against the GitHub GraphQL Explorer
    (https://docs.github.com/en/graphql/reference/mutations#convertpullrequesttodraft)
    before coding. If the input field is named `clientMutationId` + `pullRequestId`, use
    `pullRequestId`. If it expects a top-level `id`, adjust accordingly.
    The mutation returns `{ pullRequest { isDraft } }` — parse just enough to confirm success.

    Add a private method `executeDraftMutation` to Client (in graphql.go):
    ```go
    // executeDraftMutation sends a draft-toggle GraphQL mutation.
    // It returns nil on success; the caller is responsible for re-fetching PR state.
    func (c *Client) executeDraftMutation(ctx context.Context, mutation, nodeID string) error
    ```
    The implementation follows the exact same pattern as FetchThreadResolution:
    - Build graphqlRequest{Query: mutation, Variables: map[string]any{"pullRequestId": nodeID}}
    - Marshal to JSON, POST to c.graphqlURL with bearer auth header
    - Decode response into a minimal struct that checks for errors
    - If gqlResp.Errors has entries: return fmt.Errorf("GraphQL error: %s", errors[0].Message)
    - Return nil on success

    Define a minimal response struct for the mutation:
    ```go
    type draftMutationResponse struct {
        Data   map[string]any `json:"data"`
        Errors []struct {
            Message string `json:"message"`
        } `json:"errors"`
    }
    ```

    **internal/adapter/driven/github/writer.go — replace stubs:**

    Replace the ConvertPullRequestToDraft stub:
    ```go
    func (c *Client) ConvertPullRequestToDraft(ctx context.Context, repoFullName string, prNumber int) error {
        owner, repo, err := splitRepo(repoFullName)
        if err != nil {
            return err
        }
        pr, _, err := c.gh.PullRequests.Get(ctx, owner, repo, prNumber)
        if err != nil {
            return fmt.Errorf("fetching PR node ID: %w", err)
        }
        nodeID := pr.GetNodeID()
        if nodeID == "" {
            return fmt.Errorf("PR node ID is empty — cannot execute GraphQL mutation")
        }
        return c.executeDraftMutation(ctx, convertToDraftMutation, nodeID)
    }
    ```

    Replace the MarkPullRequestReadyForReview stub identically but with `markReadyMutation`.

    The compile-time check `var _ driven.GitHubWriter = (*Client)(nil)` remains. With
    these two stubs replaced, the only remaining stub is none — all five non-ValidateToken
    methods from Plan 02 and Plan 03 are now real. Remove the stub comment.
  </action>
  <verify>
    go build ./internal/adapter/driven/github/... succeeds
    go vet ./internal/adapter/driven/github/... passes
  </verify>
  <done>
    Both GraphQL draft mutations are implemented. ConvertPullRequestToDraft and
    MarkPullRequestReadyForReview fetch node_id on-demand and execute the mutation.
    GitHubWriter has no remaining stubs.
  </done>
</task>

<task type="auto">
  <name>Task 2: Draft toggle handler and PR detail header button</name>
  <files>
    internal/adapter/driving/web/handler.go
    internal/adapter/driving/web/routes.go
    internal/adapter/driving/web/viewmodel/viewmodel.go
    internal/adapter/driving/web/templates/components/pr_detail.templ
  </files>
  <action>
    **internal/adapter/driving/web/viewmodel/viewmodel.go:**
    Add IsOwnPR bool field to PRDetailViewModel (true when pr.Author == authenticatedUser).
    This is computed in the viewmodel conversion function in viewmodel.go, not in the template.
    Update toPRDetailViewModel in internal/adapter/driving/web/viewmodel.go to accept
    authenticatedUser string and set IsOwnPR = (pr.Author == authenticatedUser).

    **internal/adapter/driving/web/handler.go — add ToggleDraftStatus handler:**
    POST /app/prs/{owner}/{repo}/{number}/draft-toggle

    - Extract owner, repo, number from path
    - Authenticate: check credStore for github_token; if missing, return 422 with
      HTML error: `<p class="text-red-600 text-sm">Configure a GitHub token in Settings to toggle draft status.</p>`
    - Fetch current PR from prStore to get current IsDraft value
    - Verify PR author matches authenticated username (extra server-side check);
      if mismatch: return 403 with error fragment
    - If currently draft: call h.ghWriter.MarkPullRequestReadyForReview
    - If currently ready: call h.ghWriter.ConvertPullRequestToDraft
    - On API error: return 422 with error fragment showing the error message
    - On success: fire a background refresh via `go pollSvc.RefreshRepo(context.Background(), repoFullName)`
      so the DB catches up asynchronously. Do NOT wait for it before rendering — render
      the response immediately using the toggled state (optimistic render: flip pr.IsDraft
      in the view model before passing to the component). This avoids a stale-read race
      where the DB still has the old draft state when the handler fetches for rendering.

    The handler writes the response as a templ component rendering just the PR header
    section (the div id="pr-detail-header" containing the title, draft badge, and toggle button).

    **internal/adapter/driving/web/templates/components/pr_detail.templ — add toggle button:**
    In the PR detail header section, add a wrapping div id="pr-detail-header" around
    the title, status badges, and the new toggle button.

    Add the toggle button after the status badges, visible only if pr.IsOwnPR:
    ```templ
    if pr.IsOwnPR && pr.Status == "open" {
        <button
            hx-post={ fmt.Sprintf("/app/prs/%s/%d/draft-toggle", pr.Repository, pr.Number) }
            hx-target="#pr-detail-header"
            hx-swap="morph"
            hx-indicator="this"
            x-data="{ loading: false }"
            @htmx:before-request.camel="loading = true"
            @htmx:after-request.camel="loading = false"
            :disabled="loading"
            class="inline-flex items-center px-3 py-1.5 text-sm font-medium rounded-md border border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-700 text-gray-700 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-600 transition-colors disabled:opacity-50"
        >
            <span x-show="!loading">
                if pr.IsDraft {
                    Mark Ready for Review
                } else {
                    Convert to Draft
                }
            </span>
            <span x-show="loading" class="inline-flex items-center gap-1">
                <svg class="animate-spin h-4 w-4 text-gray-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                    <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                    <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4z"></path>
                </svg>
                Working...
            </span>
        </button>
    }
    ```

    Include a small SVG spinner inline (a simple 4-point rotate spinner in Tailwind).

    Create a new partial or add a templ component for just the header section so the
    handler can render only that section in response to the toggle POST.

    **internal/adapter/driving/web/routes.go:**
    ```go
    mux.HandleFunc("POST /app/prs/{owner}/{repo}/{number}/draft-toggle", h.ToggleDraftStatus)
    ```

    Run `templ generate`.
  </action>
  <verify>
    templ generate succeeds
    go build ./... succeeds
    go test ./... passes
    Manual: open a PR authored by the authenticated user — toggle button visible
    Manual: open a PR authored by someone else — no toggle button
    Manual: click toggle button — loading state shown, then badge updates (Draft ↔ Ready)
    Manual: API error (simulated with invalid token) — error message shown inline
  </verify>
  <done>
    REV-04: Draft toggle button is visible only on own PRs. Single-click with loading state.
    Server calls correct GraphQL mutation. Header section morphs with updated badge.
  </done>
</task>

</tasks>

<verification>
1. go build ./... succeeds
2. go test ./... passes
3. templ generate succeeds
4. Own PR → toggle button visible in header; others' PRs → no button
5. Clicking toggle on a ready PR → sends POST, waits, Draft badge appears
6. Clicking toggle on a draft PR → sends POST, waits, Draft badge disappears
7. Server-side auth check: handler rejects toggle for non-own PRs with 403
</verification>

<success_criteria>
- REV-04: Toggle button shows on own open PRs only; one click, no confirmation dialog
- GraphQL mutations execute via extended hand-rolled client (no new Go dependencies)
- Node ID fetched on-demand via REST PullRequests.Get at toggle time
- Loading state prevents double-click; error shown inline on failure
</success_criteria>

<output>
After completion, create `.planning/phases/08-review-workflows-and-attention-signals/08-04-SUMMARY.md`
</output>
