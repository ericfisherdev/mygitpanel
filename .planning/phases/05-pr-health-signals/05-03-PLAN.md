---
phase: 05-pr-health-signals
plan: 03
type: execute
wave: 3
depends_on: ["05-01", "05-02"]
files_modified:
  - internal/adapter/driving/http/response.go
  - internal/adapter/driving/http/handler.go
  - internal/adapter/driving/http/handler_test.go
  - cmd/mygitpanel/main.go
autonomous: true

must_haves:
  truths:
    - "Each PR in the detail endpoint shows CI status, diff stats, mergeable status, staleness, and individual check runs"
    - "List endpoints include lightweight health signal fields (ci_status, mergeable_status, staleness, diff stats) without fetching check run details"
    - "Composition root wires CheckRepo and HealthService into the handler and poll service"
    - "All existing tests continue to pass alongside new health signal tests"
  artifacts:
    - path: "internal/adapter/driving/http/response.go"
      provides: "CheckRunResponse, CommitStatusResponse DTOs and expanded PRResponse"
      contains: "CheckRunResponse"
    - path: "internal/adapter/driving/http/handler.go"
      provides: "HealthService integration in GetPR and health fields in list responses"
      contains: "healthSvc"
    - path: "cmd/mygitpanel/main.go"
      provides: "Full composition root wiring for Phase 5"
      contains: "NewCheckRepo"
  key_links:
    - from: "internal/adapter/driving/http/handler.go"
      to: "internal/application/healthservice.go"
      via: "healthSvc.GetPRHealthSummary in GetPR"
      pattern: "healthSvc\\.GetPRHealthSummary"
    - from: "cmd/mygitpanel/main.go"
      to: "internal/adapter/driven/sqlite/checkrepo.go"
      via: "NewCheckRepo wiring"
      pattern: "sqliteadapter\\.NewCheckRepo"
    - from: "internal/adapter/driving/http/response.go"
      to: "internal/domain/model/pullrequest.go"
      via: "toPRResponse reads health signal fields"
      pattern: "pr\\.Additions|pr\\.CIStatus|pr\\.MergeableStatus"
---

<objective>
Expose health signal data through the HTTP API and wire all Phase 5 components in the composition root.

Purpose: Make CI/CD status, diff stats, staleness, merge conflict status, and individual check runs available to API consumers via JSON endpoints. Complete the Phase 5 vertical slice by wiring CheckRepo and HealthService into the application.
Output: Expanded HTTP response DTOs with health signal fields, enriched GetPR endpoint with check run details, lightweight health fields on list endpoints, and fully wired composition root.
</objective>

<execution_context>
@/home/esfisher/.claude/get-shit-done/workflows/execute-plan.md
@/home/esfisher/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-pr-health-signals/05-RESEARCH.md
@.planning/phases/05-pr-health-signals/05-01-SUMMARY.md
@.planning/phases/05-pr-health-signals/05-02-SUMMARY.md

@internal/adapter/driving/http/response.go
@internal/adapter/driving/http/handler.go
@internal/adapter/driving/http/handler_test.go
@internal/application/healthservice.go
@cmd/mygitpanel/main.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: HTTP response DTOs and handler enrichment</name>
  <files>
    internal/adapter/driving/http/response.go
    internal/adapter/driving/http/handler.go
    internal/adapter/driving/http/handler_test.go
  </files>
  <action>
1. Add new DTO types to response.go:

   CheckRunResponse struct:
   - ID int64 `json:"id"`
   - Name string `json:"name"`
   - Status string `json:"status"`
   - Conclusion string `json:"conclusion"`
   - IsRequired bool `json:"is_required"`
   - DetailsURL string `json:"details_url"`

   (CommitStatus data is not separately persisted; the combined ci_status field covers STAT-06.)

2. Add health signal fields to PRResponse in response.go (after the existing enriched review fields section):
   - DaysSinceOpened int `json:"days_since_opened"`
   - DaysSinceLastActivity int `json:"days_since_last_activity"`
   - Additions int `json:"additions"`
   - Deletions int `json:"deletions"`
   - ChangedFiles int `json:"changed_files"`
   - MergeableStatus string `json:"mergeable_status"`
   - CIStatus string `json:"ci_status"`
   - CheckRuns []CheckRunResponse `json:"check_runs"`

3. Update toPRResponse in response.go to populate the new health signal fields from the domain model:
   - DaysSinceOpened: pr.DaysSinceOpened() (already a method on PullRequest)
   - DaysSinceLastActivity: pr.DaysSinceLastActivity() (already a method)
   - Additions: pr.Additions
   - Deletions: pr.Deletions
   - ChangedFiles: pr.ChangedFiles
   - MergeableStatus: string(pr.MergeableStatus)
   - CIStatus: string(pr.CIStatus)
   - CheckRuns: []CheckRunResponse{} (empty slice default, populated by GetPR enrichment)

   This means ALL endpoints (list and detail) return staleness metrics, diff stats, mergeable status, and CI status since those fields are on the PullRequest model. Only CheckRuns (individual check run details) are populated on the detail endpoint via HealthService -- consistent with the Phase 4 pattern where list endpoints are lightweight.

4. Add a toCheckRunResponse helper function mapping model.CheckRun to CheckRunResponse.

5. Update Handler struct in handler.go:
   - Add healthSvc *application.HealthService field.
   - Update NewHandler to accept healthSvc *application.HealthService as a parameter (add after reviewSvc).

6. Update GetPR in handler.go to enrich with health data (follows same pattern as review enrichment):
   - After the existing review enrichment block, add a health enrichment block:
   - If h.healthSvc != nil, call h.healthSvc.GetPRHealthSummary(r.Context(), pr.ID).
   - On error, log and fall through (non-fatal, same pattern as review enrichment).
   - On success, populate resp.CheckRuns by mapping summary.CheckRuns via toCheckRunResponse.
   - Note: CIStatus is already on the PR model and populated in toPRResponse, so no need to override from health summary. But if the health summary provides a more accurate computed value, overwrite resp.CIStatus with string(summary.CIStatus).

7. Update handler_test.go:
   - Update the existing mock structures: if Handler now requires healthSvc, pass nil for healthSvc in tests that don't need it (same nil-guard pattern as reviewSvc).
   - Add TestGetPR_WithHealthSignals: Create a mock CheckStore (or mock HealthService -- simpler to test with nil healthSvc and verify the basic fields from toPRResponse). Upsert a PR with health signal values via mock PRStore, call GetPR, verify JSON response contains days_since_opened, additions, deletions, changed_files, mergeable_status, ci_status, and check_runs (empty array).
   - Add TestListPRs_IncludesHealthFields: Call ListPRs, verify JSON response contains ci_status, mergeable_status, additions, deletions, changed_files, days_since_opened, days_since_last_activity on each PR object.
   - Verify all existing handler tests still pass with the updated NewHandler signature (add nil for new healthSvc parameter).
  </action>
  <verify>
Run `go test ./internal/adapter/driving/http/... -v -count=1` -- all tests pass (existing + new health signal tests).
  </verify>
  <done>
PRResponse includes all health signal fields. toPRResponse populates staleness/diff stats/mergeable/CI from domain model. GetPR enriches with individual check runs from HealthService. List endpoints include lightweight health fields. All handler tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Composition root wiring</name>
  <files>
    cmd/mygitpanel/main.go
  </files>
  <action>
1. In the "Wire adapters" section (step 5), add:
   checkStore := sqliteadapter.NewCheckRepo(db)

2. Update the PollService constructor call (step 7) to pass checkStore as the new parameter:
   pollSvc := application.NewPollService(
       ghClient,
       prStore,
       repoStore,
       reviewStore,
       checkStore,    // NEW: health signal persistence
       cfg.GitHubUsername,
       cfg.GitHubTeams,
       cfg.PollInterval,
   )

3. Create HealthService after ReviewService (step 7b):
   healthSvc := application.NewHealthService(checkStore)

4. Update the Handler constructor (step 7.5) to pass healthSvc:
   h := httphandler.NewHandler(prStore, repoStore, botConfigStore, reviewSvc, healthSvc, pollSvc, cfg.GitHubUsername, slog.Default())

5. Verify import alias sqliteadapter is already imported -- no new imports needed since all types are from existing packages.
  </action>
  <verify>
Run `go build ./cmd/mygitpanel/...` -- binary compiles. Run `go test ./... -count=1` -- ALL tests across the entire project pass. Run `go vet ./...` -- no issues.
  </verify>
  <done>
Composition root wires CheckRepo, HealthService, and updated PollService/Handler constructors. Application compiles and all tests pass. Phase 5 is complete.
  </done>
</task>

</tasks>

<verification>
- `go build ./cmd/mygitpanel/...` -- binary compiles with all Phase 5 wiring
- `go test ./... -v -count=1` -- ALL project tests pass
- `go vet ./...` -- no vet issues
- curl GET /api/v1/prs response includes ci_status, mergeable_status, additions, deletions, changed_files, days_since_opened, days_since_last_activity
- curl GET /api/v1/repos/{owner}/{repo}/prs/{number} response includes check_runs array
- JSON check_runs defaults to [] (empty array, not null)
</verification>

<success_criteria>
- PRResponse JSON has all health signal fields (ci_status, mergeable_status, additions, deletions, changed_files, days_since_opened, days_since_last_activity, check_runs)
- List endpoints show lightweight health fields (from PR model)
- Detail endpoint enriches with individual check runs (from HealthService)
- Composition root fully wired: CheckRepo -> PollService, CheckRepo -> HealthService -> Handler
- All existing + new tests pass (`go test ./... -count=1`)
- Phase 5 success criteria met: CI/CD status, individual checks with required flag, staleness, diff stats, merge conflict status
</success_criteria>

<output>
After completion, create `.planning/phases/05-pr-health-signals/05-03-SUMMARY.md`
</output>
