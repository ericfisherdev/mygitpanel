---
phase: 05-pr-health-signals
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - internal/adapter/driven/github/client.go
  - internal/adapter/driven/github/client_test.go
  - internal/application/healthservice.go
  - internal/application/healthservice_test.go
  - internal/application/pollservice.go
autonomous: true

must_haves:
  truths:
    - "GitHub adapter fetches check runs via Checks API with pagination"
    - "GitHub adapter fetches combined status from Status API"
    - "GitHub adapter fetches diff stats and mergeable status from single-PR GET endpoint"
    - "GitHub adapter fetches required status checks from branch protection with graceful 404/403 degradation"
    - "Health service computes combined CI status by aggregating Checks API + Status API results"
    - "Health service marks check runs as required/optional based on branch protection data"
    - "Poll service fetches health signals for changed PRs and persists them"
    - "Mergeable null from GitHub maps to MergeableUnknown (not false)"
  artifacts:
    - path: "internal/adapter/driven/github/client.go"
      provides: "FetchCheckRuns, FetchCombinedStatus, FetchPRDetail, FetchRequiredStatusChecks implementations"
      contains: "FetchCheckRuns"
    - path: "internal/application/healthservice.go"
      provides: "HealthService with ComputeCombinedCIStatus and GetPRHealthSummary"
      contains: "type HealthService struct"
    - path: "internal/application/pollservice.go"
      provides: "fetchHealthData integration in poll cycle"
      contains: "fetchHealthData"
  key_links:
    - from: "internal/adapter/driven/github/client.go"
      to: "internal/domain/port/driven/githubclient.go"
      via: "compile-time interface check"
      pattern: "var _ driven\\.GitHubClient"
    - from: "internal/application/pollservice.go"
      to: "internal/adapter/driven/github/client.go"
      via: "ghClient.FetchCheckRuns in fetchHealthData"
      pattern: "ghClient\\.FetchCheckRuns"
    - from: "internal/application/healthservice.go"
      to: "internal/domain/port/driven/checkstore.go"
      via: "checkStore.GetCheckRunsByPR"
      pattern: "checkStore\\.GetCheckRunsByPR"
---

<objective>
Implement GitHub API data fetching for health signals and the aggregation service.

Purpose: Connect to GitHub's Checks API, Status API, single-PR endpoint, and branch protection endpoint; compute combined CI status; integrate health signal fetching into the poll cycle so data is persisted and ready for the HTTP layer in Plan 03.
Output: Four new GitHub adapter methods with tests, HealthService with CI status computation, and poll service integration for health signal fetching during poll cycles.
</objective>

<execution_context>
@/home/esfisher/.claude/get-shit-done/workflows/execute-plan.md
@/home/esfisher/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-pr-health-signals/05-RESEARCH.md
@.planning/phases/05-pr-health-signals/05-01-SUMMARY.md

@internal/adapter/driven/github/client.go
@internal/adapter/driven/github/client_test.go
@internal/application/pollservice.go
@internal/application/reviewservice.go
@internal/domain/model/checkstatus.go
@internal/domain/model/pullrequest.go
@internal/domain/model/enums.go
@internal/domain/port/driven/githubclient.go
@internal/domain/port/driven/checkstore.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: GitHub adapter methods for health signal data</name>
  <files>
    internal/adapter/driven/github/client.go
    internal/adapter/driven/github/client_test.go
  </files>
  <action>
Add four new methods to the GitHub adapter Client in client.go. Follow the same patterns used by FetchReviews/FetchReviewComments (pagination, splitRepo, mapXxx helpers, logRateLimit).

1. FetchCheckRuns(ctx, repoFullName, ref) ([]model.CheckRun, error):
   - Call c.gh.Checks.ListCheckRunsForRef(ctx, owner, repo, ref, opts) with PerPage: 100 and pagination.
   - Map each *gh.CheckRun to model.CheckRun via a mapCheckRun helper.
   - mapCheckRun extracts: ID via GetID(), Name via GetName(), Status via GetStatus(), Conclusion via GetConclusion(), IsRequired defaults to false (set later by health service), DetailsURL via GetDetailsURL(), StartedAt from cr.StartedAt (nil-safe via GetStartedAt().Time -- if cr.StartedAt is nil, zero time), CompletedAt from cr.CompletedAt (same nil-safe pattern). Set PRID to 0 (caller assigns).
   - Log rate limit after each page.

2. FetchCombinedStatus(ctx, repoFullName, ref) (*model.CombinedStatus, error):
   - Call c.gh.Repositories.GetCombinedStatus(ctx, owner, repo, ref, nil).
   - Map *gh.CombinedStatus to *model.CombinedStatus via mapCombinedStatus helper.
   - mapCombinedStatus extracts: State via GetState(). Iterate cs.Statuses, map each to model.CommitStatus with Context via GetContext(), State via GetState(), Description via GetDescription(), TargetURL via GetTargetURL().
   - Return nil, nil if combined status has zero statuses and state is empty (no CI configured).

3. FetchPRDetail(ctx, repoFullName, prNumber) (*model.PRDetail, error):
   - Call c.gh.PullRequests.Get(ctx, owner, repo, prNumber).
   - Build model.PRDetail with Additions: pr.GetAdditions(), Deletions: pr.GetDeletions(), ChangedFiles: pr.GetChangedFiles(), Mergeable: mapMergeable(pr.Mergeable).
   - mapMergeable(mergeable *bool) model.MergeableStatus: if nil return MergeableUnknown, if true return MergeableMergeable, if false return MergeableConflicted.

4. FetchRequiredStatusChecks(ctx, repoFullName, branch) ([]string, error):
   - Call c.gh.Repositories.GetRequiredStatusChecks(ctx, owner, repo, branch).
   - On error: if resp.StatusCode == 404 or 403, return nil, nil (branch not protected or insufficient permissions -- these are expected non-fatal cases per research).
   - On success: if checks.Checks is nil, return nil, nil. Otherwise iterate *checks.Checks, collect each check.Context into a []string, return it.
   - Note: The go-github RequiredStatusChecks struct has a Checks field of type *[]*RequiredStatusCheck. Each RequiredStatusCheck has Context string field.

Add tests in client_test.go using httptest server (follow existing test patterns in the file):
- TestFetchCheckRuns: Mock the /repos/{owner}/{repo}/commits/{ref}/check-runs endpoint, return 2 check runs JSON, verify mapping.
- TestFetchCombinedStatus: Mock /repos/{owner}/{repo}/commits/{ref}/status, return combined status with 1 status entry, verify mapping.
- TestFetchPRDetail: Mock /repos/{owner}/{repo}/pulls/{number}, return PR with additions/deletions/changed_files/mergeable, verify mapping.
- TestFetchPRDetail_MergeableNull: Same but mergeable is null (omitted from JSON), verify MergeableUnknown.
- TestFetchRequiredStatusChecks_Success: Mock branch protection endpoint, return required checks.
- TestFetchRequiredStatusChecks_404: Mock 404 response, verify nil, nil (no error).
- TestFetchRequiredStatusChecks_403: Mock 403 response, verify nil, nil (no error).
  </action>
  <verify>
Run `go test ./internal/adapter/driven/github/... -v -count=1` -- all tests pass. The compile-time check `var _ driven.GitHubClient = (*Client)(nil)` continues to pass (all 4 new interface methods implemented).
  </verify>
  <done>
FetchCheckRuns, FetchCombinedStatus, FetchPRDetail, FetchRequiredStatusChecks are implemented with pagination, proper go-github type mapping, and graceful degradation. All adapter tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Health service and poll service integration</name>
  <files>
    internal/application/healthservice.go
    internal/application/healthservice_test.go
    internal/application/pollservice.go
  </files>
  <action>
1. Create HealthService in healthservice.go following the same pattern as ReviewService:
   - Struct: HealthService with checkStore driven.CheckStore field. Constructor: NewHealthService(checkStore driven.CheckStore) *HealthService.
   - Export a PRHealthSummary struct containing:
     - CheckRuns []model.CheckRun
     - CIStatus model.CIStatus (the computed combined status)
   - Method GetPRHealthSummary(ctx, prID) (*PRHealthSummary, error):
     - Load check runs via checkStore.GetCheckRunsByPR(ctx, prID).
     - Compute CI status from the stored check runs using computeCombinedCIStatus (note: at this point, commit statuses have already been combined during poll and the aggregated ci_status is on the PR model -- but for the detail view we recompute from individual runs for accuracy).
     - Return PRHealthSummary with the check runs and computed status.

2. Create the core aggregation function computeCombinedCIStatus(checkRuns []model.CheckRun, combinedStatus *model.CombinedStatus) model.CIStatus as an unexported package-level function (follows Phase 4 enrichment helper pattern):
   - If no check runs AND combined status is nil or empty, return CIStatusUnknown.
   - Iterate check runs:
     - If status == "completed" AND conclusion in {failure, cancelled, timed_out, action_required}: hasFailing = true
     - If status != "completed" (queued, in_progress, waiting, requested, pending): hasPending = true
     - If status == "completed" AND conclusion in {success, neutral, skipped}: passing (no flag)
   - If combined status not nil: if state == "failure" -> hasFailing; if state == "pending" -> hasPending; "success" -> passing.
   - Return: if hasFailing -> CIStatusFailing; if hasPending -> CIStatusPending; else CIStatusPassing.

3. Create a helper function markRequiredChecks(checkRuns []model.CheckRun, requiredContexts []string) that sets IsRequired = true on check runs whose Name matches any entry in requiredContexts (case-insensitive comparison). This is called during poll before persisting. If requiredContexts is nil (branch protection unavailable), all checks remain IsRequired = false.

4. Update PollService:
   - Add checkStore driven.CheckStore as a new dependency field.
   - Update NewPollService constructor to accept checkStore driven.CheckStore as a parameter (add after reviewStore).
   - Add a fetchHealthData(ctx, pr model.PullRequest) method following the same partial-failure pattern as fetchReviewData:
     - Step 1: Call ghClient.FetchPRDetail(ctx, pr.RepoFullName, pr.Number). On success, update the stored PR: set pr.Additions, pr.Deletions, pr.ChangedFiles, pr.MergeableStatus from the PRDetail, then call prStore.Upsert(ctx, pr) to persist. On failure, log and continue.
     - Step 2: Call ghClient.FetchCheckRuns(ctx, pr.RepoFullName, pr.HeadSHA). On failure, log and continue (skip remaining check processing).
     - Step 3: Call ghClient.FetchCombinedStatus(ctx, pr.RepoFullName, pr.HeadSHA). On failure, log and continue (use nil for combined status in aggregation).
     - Step 4: Call ghClient.FetchRequiredStatusChecks(ctx, pr.RepoFullName, pr.BaseBranch). On failure, log and continue (requiredContexts remains nil -- all checks default to not required).
     - Step 5: Call markRequiredChecks(checkRuns, requiredContexts) to tag required checks.
     - Step 6: Set PRID on all check runs to pr.ID (same PRID=0 convention as reviews -- caller assigns).
     - Step 7: Call checkStore.ReplaceCheckRunsForPR(ctx, pr.ID, checkRuns) to persist.
     - Step 8: Compute combined CI status via computeCombinedCIStatus(checkRuns, combinedStatus). Update pr.CIStatus and call prStore.Upsert(ctx, pr) again to persist the computed ci_status.
     - Log a debug message summarizing: check_runs count, ci_status, mergeable_status.
   - In pollRepo, after fetchReviewData(ctx, *storedPR), add a call to s.fetchHealthData(ctx, *storedPR). This runs for every changed PR (same gating as review data).

5. Create healthservice_test.go:
   - Test computeCombinedCIStatus with table-driven cases:
     - All passing check runs + success status -> CIStatusPassing
     - One failing check run -> CIStatusFailing
     - One pending check run (status != "completed") -> CIStatusPending
     - Failing takes precedence over pending -> CIStatusFailing
     - No check runs, no combined status -> CIStatusUnknown
     - No check runs, combined status "failure" -> CIStatusFailing
     - No check runs, combined status "pending" -> CIStatusPending
     - Check runs passing, combined status failing -> CIStatusFailing (any failure wins)
     - Neutral/skipped conclusions -> treated as passing
   - Test markRequiredChecks:
     - Two check runs, one name matches required context -> only that one IsRequired=true
     - Nil required contexts -> all IsRequired=false
     - Case-insensitive match
   - Test GetPRHealthSummary with mock CheckStore (mock struct in test file, follows existing mock pattern from handler_test.go).
  </action>
  <verify>
Run `go test ./internal/application/... -v -count=1` -- all tests pass (existing review service tests + new health service tests). Run `go build ./...` -- full project compiles (GitHub adapter implements expanded interface, PollService updated constructor compiles against main.go -- note: main.go will need checkStore wiring in Plan 03, but the build should still pass because we are adding a parameter; if it breaks main.go, add a TODO comment and fix in Plan 03).
  </verify>
  <done>
HealthService computes combined CI status from dual check sources. PollService fetches check runs, combined status, PR detail, and required checks for changed PRs with partial-failure tolerance. All new functions have passing tests.
  </done>
</task>

</tasks>

<verification>
- `go test ./internal/adapter/driven/github/... -v -count=1` -- GitHub adapter tests pass
- `go test ./internal/application/... -v -count=1` -- health service + poll service tests pass
- `go vet ./...` -- no vet issues
- Combined CI status correctly prioritizes: failing > pending > passing > unknown
- Branch protection 404/403 handled gracefully (nil, nil -- not error)
- Mergeable null maps to MergeableUnknown
</verification>

<success_criteria>
- Four new GitHub adapter methods implemented with httptest-based tests
- HealthService with computeCombinedCIStatus and markRequiredChecks functions, tested
- PollService.fetchHealthData fetches and persists health signals for changed PRs
- PollService constructor accepts checkStore dependency
- All tests pass, project compiles
</success_criteria>

<output>
After completion, create `.planning/phases/05-pr-health-signals/05-02-SUMMARY.md`
</output>
