---
phase: 05-pr-health-signals
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/domain/model/pullrequest.go
  - internal/domain/model/checkstatus.go
  - internal/domain/model/enums.go
  - internal/domain/port/driven/githubclient.go
  - internal/domain/port/driven/checkstore.go
  - internal/adapter/driven/sqlite/prrepo.go
  - internal/adapter/driven/sqlite/prrepo_test.go
  - internal/adapter/driven/sqlite/checkrepo.go
  - internal/adapter/driven/sqlite/checkrepo_test.go
  - internal/adapter/driven/sqlite/migrations/000008_add_health_signals.up.sql
  - internal/adapter/driven/sqlite/migrations/000008_add_health_signals.down.sql
  - internal/adapter/driven/sqlite/migrations/000009_add_check_runs.up.sql
  - internal/adapter/driven/sqlite/migrations/000009_add_check_runs.down.sql
autonomous: true

must_haves:
  truths:
    - "CheckRun and CombinedStatus/CommitStatus domain models exist as pure Go structs with zero external dependencies"
    - "MergeableStatus enum has three values (mergeable, conflicted, unknown)"
    - "PullRequest model has Additions, Deletions, ChangedFiles, MergeableStatus, and CIStatus fields"
    - "CheckStore port interface defines CRUD methods for check run persistence"
    - "GitHubClient port interface declares FetchCheckRuns, FetchCombinedStatus, FetchPRDetail, FetchRequiredStatusChecks"
    - "SQLite migrations add health signal columns to pull_requests and create check_runs table"
    - "CheckRepo SQLite adapter implements CheckStore with passing tests"
    - "PRRepo Upsert persists and reads back new health signal fields correctly"
  artifacts:
    - path: "internal/domain/model/checkstatus.go"
      provides: "CheckRun, CombinedStatus, CommitStatus domain entities"
      contains: "type CheckRun struct"
    - path: "internal/domain/model/enums.go"
      provides: "MergeableStatus enum"
      contains: "MergeableStatus"
    - path: "internal/domain/model/pullrequest.go"
      provides: "Health signal fields on PullRequest"
      contains: "Additions"
    - path: "internal/domain/port/driven/checkstore.go"
      provides: "CheckStore port interface"
      contains: "type CheckStore interface"
    - path: "internal/domain/port/driven/githubclient.go"
      provides: "Expanded GitHubClient port with health signal methods"
      contains: "FetchCheckRuns"
    - path: "internal/adapter/driven/sqlite/checkrepo.go"
      provides: "SQLite CheckStore implementation"
      contains: "type CheckRepo struct"
    - path: "internal/adapter/driven/sqlite/migrations/000008_add_health_signals.up.sql"
      provides: "Health signal columns on pull_requests"
      contains: "ALTER TABLE pull_requests"
    - path: "internal/adapter/driven/sqlite/migrations/000009_add_check_runs.up.sql"
      provides: "check_runs table schema"
      contains: "CREATE TABLE"
  key_links:
    - from: "internal/adapter/driven/sqlite/checkrepo.go"
      to: "internal/domain/port/driven/checkstore.go"
      via: "compile-time interface check"
      pattern: "var _ driven\\.CheckStore"
    - from: "internal/adapter/driven/sqlite/prrepo.go"
      to: "internal/domain/model/pullrequest.go"
      via: "Upsert writes new fields"
      pattern: "additions.*deletions.*changed_files.*mergeable_status.*ci_status"
---

<objective>
Expand domain model with health signal entities and persistence layer for Phase 5.

Purpose: Establish the data foundation (types, ports, persistence) that the GitHub adapter and health service will depend on in Plan 02.
Output: Domain models (CheckRun, CombinedStatus, CommitStatus, MergeableStatus enum), expanded PullRequest with diff stats/mergeable/CI fields, CheckStore port, GitHubClient port expansion, SQLite migrations, and CheckRepo + PRRepo adapter updates with tests.
</objective>

<execution_context>
@/home/esfisher/.claude/get-shit-done/workflows/execute-plan.md
@/home/esfisher/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-pr-health-signals/05-RESEARCH.md

@internal/domain/model/pullrequest.go
@internal/domain/model/checkstatus.go
@internal/domain/model/enums.go
@internal/domain/port/driven/githubclient.go
@internal/domain/port/driven/prstore.go
@internal/adapter/driven/sqlite/prrepo.go
@internal/adapter/driven/sqlite/prrepo_test.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Domain model expansion and port interfaces</name>
  <files>
    internal/domain/model/pullrequest.go
    internal/domain/model/checkstatus.go
    internal/domain/model/enums.go
    internal/domain/port/driven/githubclient.go
    internal/domain/port/driven/checkstore.go
  </files>
  <action>
1. Add MergeableStatus enum to enums.go with three values: MergeableMergeable ("mergeable"), MergeableConflicted ("conflicted"), MergeableUnknown ("unknown").

2. Add five new persisted fields to the PullRequest struct in pullrequest.go (after HeadSHA, before Labels):
   - Additions int
   - Deletions int
   - ChangedFiles int
   - MergeableStatus MergeableStatus (default MergeableUnknown)
   - CIStatus CIStatus (default CIStatusUnknown)

3. Replace the existing CheckStatus struct in checkstatus.go with the following domain entities (the existing CheckStatus is a Phase 1 placeholder that was never persisted -- it can be fully replaced):

   CheckRun -- represents an individual CI/CD check run from the Checks API:
   - ID int64 (GitHub check run ID, used as PK)
   - PRID int64 (foreign key to pull_requests)
   - Name string
   - Status string (queued, in_progress, completed, waiting, requested, pending)
   - Conclusion string (success, failure, neutral, cancelled, skipped, timed_out, action_required)
   - IsRequired bool (from branch protection cross-reference)
   - DetailsURL string
   - StartedAt time.Time
   - CompletedAt time.Time

   CombinedStatus -- aggregated status from the Status API:
   - State string (success, failure, pending)
   - Statuses []CommitStatus

   CommitStatus -- individual entry from the Status API:
   - Context string (CI service identifier, e.g. "ci/circleci")
   - State string (success, failure, pending, error)
   - Description string
   - TargetURL string

   PRDetail -- returned by single-PR GET endpoint (used as data transfer, not persisted separately):
   - Additions int
   - Deletions int
   - ChangedFiles int
   - Mergeable MergeableStatus

4. Add four new methods to the GitHubClient interface in githubclient.go:
   - FetchCheckRuns(ctx context.Context, repoFullName string, ref string) ([]model.CheckRun, error)
   - FetchCombinedStatus(ctx context.Context, repoFullName string, ref string) (*model.CombinedStatus, error)
   - FetchPRDetail(ctx context.Context, repoFullName string, prNumber int) (*model.PRDetail, error)
   - FetchRequiredStatusChecks(ctx context.Context, repoFullName string, branch string) ([]string, error)

5. Create a new CheckStore port interface in checkstore.go:
   - ReplaceCheckRunsForPR(ctx context.Context, prID int64, runs []model.CheckRun) error -- deletes existing then bulk inserts (full replacement strategy per research)
   - GetCheckRunsByPR(ctx context.Context, prID int64) ([]model.CheckRun, error)

   Keep it minimal per ISP. No individual upsert -- full replacement is simpler than per-run upsert and handles stale check cleanup.
  </action>
  <verify>
Run `go build ./internal/domain/...` -- should compile with no errors. All domain model files should have zero non-stdlib imports. The GitHubClient interface expansion will cause build failures in the github adapter (expected -- fixed in Plan 02).
  </verify>
  <done>
Five new fields on PullRequest, MergeableStatus enum, CheckRun/CombinedStatus/CommitStatus/PRDetail entities, CheckStore port, and GitHubClient port with 4 new methods all compile. Domain package depends only on stdlib time.
  </done>
</task>

<task type="auto">
  <name>Task 2: SQLite migrations and adapter implementations</name>
  <files>
    internal/adapter/driven/sqlite/migrations/000008_add_health_signals.up.sql
    internal/adapter/driven/sqlite/migrations/000008_add_health_signals.down.sql
    internal/adapter/driven/sqlite/migrations/000009_add_check_runs.up.sql
    internal/adapter/driven/sqlite/migrations/000009_add_check_runs.down.sql
    internal/adapter/driven/sqlite/prrepo.go
    internal/adapter/driven/sqlite/prrepo_test.go
    internal/adapter/driven/sqlite/checkrepo.go
    internal/adapter/driven/sqlite/checkrepo_test.go
  </files>
  <action>
1. Create migration 000008_add_health_signals:
   - up.sql: ALTER TABLE pull_requests to add five columns: additions (INTEGER NOT NULL DEFAULT 0), deletions (INTEGER NOT NULL DEFAULT 0), changed_files (INTEGER NOT NULL DEFAULT 0), mergeable_status (TEXT NOT NULL DEFAULT 'unknown'), ci_status (TEXT NOT NULL DEFAULT 'unknown').
   - down.sql: Five ALTER TABLE DROP COLUMN statements (SQLite 3.35+ supports this, modernc.org/sqlite supports it).

2. Create migration 000009_add_check_runs:
   - up.sql: CREATE TABLE check_runs with columns: id (INTEGER PRIMARY KEY -- GitHub check run ID, NOT autoincrement), pr_id (INTEGER NOT NULL), name (TEXT NOT NULL), status (TEXT NOT NULL DEFAULT ''), conclusion (TEXT NOT NULL DEFAULT ''), is_required (INTEGER NOT NULL DEFAULT 0), details_url (TEXT NOT NULL DEFAULT ''), started_at (DATETIME), completed_at (DATETIME), FOREIGN KEY (pr_id) REFERENCES pull_requests(id) ON DELETE CASCADE. Create index idx_check_runs_pr_id on pr_id.
   - down.sql: DROP TABLE IF EXISTS check_runs; DROP INDEX IF EXISTS idx_check_runs_pr_id;

3. Update PRRepo.Upsert in prrepo.go:
   - Add the 5 new columns to the INSERT column list AND the ON CONFLICT DO UPDATE SET clause.
   - Add the 5 new values to the ExecContext args: pr.Additions, pr.Deletions, pr.ChangedFiles, string(pr.MergeableStatus), string(pr.CIStatus).
   - Handle default: if pr.MergeableStatus is empty string, default to "unknown". If pr.CIStatus is empty string, default to "unknown".

4. Update scanPR in prrepo.go:
   - Add scan targets for the 5 new columns (additions int, deletions int, changedFiles int, mergeableStatus string, ciStatus string).
   - Map scanned values back: pr.Additions = additions, pr.Deletions = deletions, pr.ChangedFiles = changedFiles, pr.MergeableStatus = model.MergeableStatus(mergeableStatus), pr.CIStatus = model.CIStatus(ciStatus).
   - Update ALL query strings in PRRepo that use the SELECT column list (GetByRepository, GetByStatus, GetByNumber, ListAll, ListNeedingReview) to include the 5 new columns in the correct position (after head_sha, before opened_at).

5. Update prrepo_test.go:
   - Add a test that upserts a PR with health signal values (Additions=10, Deletions=5, ChangedFiles=3, MergeableStatus=MergeableMergeable, CIStatus=CIStatusPassing), then reads it back and verifies all fields round-trip correctly.
   - Add a test that upserts a PR with zero-value/default health signals (MergeableStatus="", CIStatus="") and verifies they default to "unknown".

6. Create CheckRepo in checkrepo.go:
   - Struct: CheckRepo with db *DB field. Constructor: NewCheckRepo(db *DB) *CheckRepo.
   - Compile-time check: var _ driven.CheckStore = (*CheckRepo)(nil).
   - ReplaceCheckRunsForPR: execute DELETE FROM check_runs WHERE pr_id = ? on writer, then INSERT each check run with all fields. Use a transaction (db.Writer.BeginTx) wrapping the delete + inserts. Map IsRequired bool to int 0/1.
   - GetCheckRunsByPR: SELECT all columns from check_runs WHERE pr_id = ? ORDER BY name on reader. Scan started_at/completed_at as nullable strings (they can be NULL). Map is_required int to bool.

7. Create checkrepo_test.go:
   - Follow existing pattern: use setupTestDB(t) from testhelper_test.go. Create a PR first (via PRRepo.Upsert) to get a valid pr_id.
   - Test ReplaceCheckRunsForPR: insert 2 check runs, verify GetCheckRunsByPR returns both with correct fields. Then replace with 1 different check run, verify only the new one exists (old ones deleted).
   - Test GetCheckRunsByPR with empty result (no check runs for PR).
   - Test ReplaceCheckRunsForPR with empty slice (should delete existing, return empty on get).
  </action>
  <verify>
Run `go test ./internal/adapter/driven/sqlite/... -v -count=1` -- all tests pass including new health signal and check run tests. Run `go vet ./internal/adapter/driven/sqlite/...` -- no issues.
  </verify>
  <done>
Migrations 000008 and 000009 exist. PRRepo correctly persists and reads all 5 new PullRequest health signal fields. CheckRepo implements CheckStore (ReplaceCheckRunsForPR, GetCheckRunsByPR) with full replacement strategy and passing tests.
  </done>
</task>

</tasks>

<verification>
- `go build ./internal/domain/...` compiles (domain layer)
- `go test ./internal/adapter/driven/sqlite/... -v -count=1` -- all tests pass
- `go vet ./internal/...` -- no vet issues
- New fields round-trip through SQLite (insert + read = same values)
- CheckRepo full replacement works (delete old + insert new in transaction)
</verification>

<success_criteria>
- Domain model has CheckRun, CombinedStatus, CommitStatus, PRDetail entities and MergeableStatus enum
- PullRequest has 5 new persisted fields (Additions, Deletions, ChangedFiles, MergeableStatus, CIStatus)
- GitHubClient port has 4 new methods declared
- CheckStore port exists with 2 methods
- SQLite migrations 000008 and 000009 create the necessary schema
- PRRepo and CheckRepo adapters persist and read all new data correctly with passing tests
</success_criteria>

<output>
After completion, create `.planning/phases/05-pr-health-signals/05-01-SUMMARY.md`
</output>
