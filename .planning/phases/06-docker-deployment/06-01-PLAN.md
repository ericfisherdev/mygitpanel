---
phase: 06-docker-deployment
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Dockerfile
  - docker-compose.yml
  - .dockerignore
  - .env.example
  - cmd/healthcheck/main.go
  - cmd/mygitpanel/main.go
  - go.mod
  - go.sum
autonomous: false

must_haves:
  truths:
    - "docker compose up builds and starts the application container"
    - "API is accessible at localhost:8080 from the host"
    - "SQLite data persists across container restarts"
    - "Docker image is scratch-based with no base OS"
    - "Container health check reports healthy via docker ps"
  artifacts:
    - path: "Dockerfile"
      provides: "Multi-stage build: golang:1.25-alpine -> scratch"
      contains: "FROM scratch"
    - path: "docker-compose.yml"
      provides: "Service definition with named volume and env_file"
      contains: "mygitpanel-data:/data"
    - path: ".dockerignore"
      provides: "Excludes .git, .planning, .env, *.db from build context"
      contains: ".git"
    - path: ".env.example"
      provides: "Template showing required and optional env vars"
      contains: "MYGITPANEL_GITHUB_TOKEN"
    - path: "cmd/healthcheck/main.go"
      provides: "Minimal binary that hits /api/v1/health and exits 0 or 1"
      min_lines: 15
    - path: "cmd/mygitpanel/main.go"
      provides: "x509roots/fallback blank import for CA cert embedding"
      contains: "x509roots/fallback"
  key_links:
    - from: "cmd/healthcheck/main.go"
      to: "/api/v1/health"
      via: "HTTP GET to listen address"
      pattern: "api/v1/health"
    - from: "docker-compose.yml"
      to: "Dockerfile"
      via: "build context"
      pattern: "build:"
    - from: "Dockerfile"
      to: "cmd/mygitpanel"
      via: "go build"
      pattern: "go build.*cmd/mygitpanel"
    - from: "Dockerfile"
      to: "cmd/healthcheck"
      via: "go build"
      pattern: "go build.*cmd/healthcheck"
---

<objective>
Containerize the application with a minimal scratch-based Docker image, Docker Compose one-command startup, SQLite volume persistence, and a healthcheck binary.

Purpose: Fulfills INFR-03 (Docker container), INFR-04 (SQLite volume persistence), and the "docker compose up" success criterion. This is the final deployment milestone for the project.
Output: Dockerfile, docker-compose.yml, .dockerignore, .env.example, cmd/healthcheck/main.go, updated cmd/mygitpanel/main.go with CA cert embedding.
</objective>

<execution_context>
@/home/esfisher/.claude/get-shit-done/workflows/execute-plan.md
@/home/esfisher/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-docker-deployment/06-RESEARCH.md

@cmd/mygitpanel/main.go
@internal/config/config.go
@internal/adapter/driving/http/handler.go
@go.mod
</context>

<tasks>

<task type="auto">
  <name>Task 1: Healthcheck binary and CA cert embedding</name>
  <files>
    cmd/healthcheck/main.go
    cmd/mygitpanel/main.go
    go.mod
    go.sum
  </files>
  <action>
    1. Add the x509roots/fallback dependency:
       Run `go get golang.org/x/crypto/x509roots/fallback` to add the CA cert embedding package.

    2. Create `cmd/healthcheck/main.go`:
       A minimal Go binary for Docker HEALTHCHECK in scratch images (no shell/curl available).
       - Read `MYGITPANEL_LISTEN_ADDR` env var, default to `0.0.0.0:8080` (matches compose override).
       - Create an http.Client with 2-second timeout.
       - GET `http://{addr}/api/v1/health`.
       - Exit 0 on 200 OK, exit 1 on any error or non-200 status.
       - Close response body on success path to avoid leaks.
       - No imports beyond stdlib (net/http, os, time).

    3. Update `cmd/mygitpanel/main.go`:
       Add a blank import for CA cert embedding in the import block:
       `_ "golang.org/x/crypto/x509roots/fallback" // Embed CA certs for scratch container`
       This ensures TLS works in scratch images where /etc/ssl/certs does not exist.

    4. Verify both binaries compile with CGO disabled:
       Run `CGO_ENABLED=0 go build ./cmd/mygitpanel && CGO_ENABLED=0 go build ./cmd/healthcheck`
       Run `go test ./...` to confirm no regressions.
  </action>
  <verify>
    - `CGO_ENABLED=0 go build -o /dev/null ./cmd/mygitpanel` succeeds
    - `CGO_ENABLED=0 go build -o /dev/null ./cmd/healthcheck` succeeds
    - `go test ./...` passes all existing tests
    - `grep -q "x509roots/fallback" cmd/mygitpanel/main.go` confirms CA cert import
  </verify>
  <done>
    Both cmd/mygitpanel and cmd/healthcheck compile with CGO_ENABLED=0. The x509roots/fallback import is present in main.go. All existing tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Dockerfile, Docker Compose, and supporting config files</name>
  <files>
    Dockerfile
    docker-compose.yml
    .dockerignore
    .env.example
  </files>
  <action>
    1. Create `Dockerfile` (multi-stage build):
       **Build stage** (`golang:1.25-alpine AS build`):
       - WORKDIR /src
       - COPY go.mod go.sum first, then `go mod download && go mod verify` (cache layer)
       - COPY . . then build both binaries:
         `CGO_ENABLED=0 GOOS=linux go build -trimpath -ldflags="-s -w" -o /bin/mygitpanel ./cmd/mygitpanel`
         `CGO_ENABLED=0 GOOS=linux go build -trimpath -ldflags="-s -w" -o /bin/healthcheck ./cmd/healthcheck`
       - `mkdir -p /data /tmp` (empty dirs needed in scratch)

       **Runtime stage** (`FROM scratch`):
       - COPY --from=build /bin/mygitpanel and /bin/healthcheck
       - COPY --from=build /data /data (volume mount target)
       - COPY --from=build /tmp /tmp (precautionary for SQLite temp files)
       - EXPOSE 8080
       - VOLUME /data
       - HEALTHCHECK --interval=30s --timeout=3s --start-period=10s --retries=3 CMD ["/bin/healthcheck"]
       - ENTRYPOINT ["/bin/mygitpanel"]

       Note: No CA cert COPY needed -- certs are embedded in binary via x509roots/fallback.

    2. Create `docker-compose.yml`:
       ```yaml
       services:
         mygitpanel:
           build:
             context: .
             dockerfile: Dockerfile
           ports:
             - "127.0.0.1:8080:8080"
           volumes:
             - mygitpanel-data:/data
           env_file:
             - .env
           environment:
             MYGITPANEL_DB_PATH: /data/mygitpanel.db
             MYGITPANEL_LISTEN_ADDR: "0.0.0.0:8080"
           restart: unless-stopped

       volumes:
         mygitpanel-data:
       ```
       CRITICAL: `MYGITPANEL_LISTEN_ADDR` must be `0.0.0.0:8080` inside the container (not 127.0.0.1) because Docker port forwarding cannot reach the container's loopback. Host-side localhost restriction is achieved via `127.0.0.1:8080:8080` in ports.

    3. Create `.dockerignore`:
       Exclude: .git, .gitignore, .planning, *.md, *.db, *.db-wal, *.db-shm, .env, .env.*, CLAUDE.md

    4. Create `.env.example`:
       Template with required vars (MYGITPANEL_GITHUB_TOKEN, MYGITPANEL_GITHUB_USERNAME) and optional vars (MYGITPANEL_GITHUB_TEAMS, MYGITPANEL_POLL_INTERVAL) with comments. Do NOT include MYGITPANEL_DB_PATH or MYGITPANEL_LISTEN_ADDR as those are set in docker-compose.yml.

    5. Add `.env` to `.gitignore` if not already present (prevent secret leakage).
  </action>
  <verify>
    - `cat Dockerfile | grep "FROM scratch"` confirms scratch base
    - `cat docker-compose.yml | grep "0.0.0.0:8080"` confirms container listen address override
    - `cat docker-compose.yml | grep "127.0.0.1:8080:8080"` confirms host-side localhost binding
    - `cat docker-compose.yml | grep "mygitpanel-data:/data"` confirms volume mount
    - `cat .dockerignore | grep ".git"` confirms build context exclusions
    - `cat .env.example | grep "MYGITPANEL_GITHUB_TOKEN"` confirms template exists
    - `grep -q ".env" .gitignore` confirms .env is gitignored
  </verify>
  <done>
    Dockerfile uses multi-stage build with scratch base. docker-compose.yml has correct listen address override (0.0.0.0 inside, 127.0.0.1 on host), named volume for SQLite persistence, and env_file for secrets. .dockerignore excludes non-build files. .env.example provides user template. .env is gitignored.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Complete Docker containerization: multi-stage scratch Dockerfile, docker-compose.yml with SQLite volume persistence, healthcheck binary, CA cert embedding, .env template.</what-built>
  <how-to-verify>
    1. Copy .env.example to .env and fill in your GitHub token and username:
       `cp .env.example .env && $EDITOR .env`
    2. Build and start: `docker compose up --build -d`
    3. Wait 15 seconds for startup, then check:
       - `docker ps` -- container should show "healthy" status
       - `curl http://localhost:8080/api/v1/health` -- should return `{"status":"ok",...}`
       - `curl http://localhost:8080/api/v1/repos` -- should return `[]` (empty initially)
    4. Add a repo: `curl -X POST http://localhost:8080/api/v1/repos -d '{"full_name":"your/repo"}'`
    5. Verify persistence: `docker compose down && docker compose up -d`
       Wait 15 seconds, then `curl http://localhost:8080/api/v1/repos` -- repo should still be listed
    6. Check image size: `docker images mygitpanel-mygitpanel` -- should be ~20-30MB
  </how-to-verify>
  <resume-signal>Type "approved" or describe issues</resume-signal>
</task>

</tasks>

<verification>
- `docker compose up --build -d` starts container without errors
- `docker ps` shows container as healthy after start-period (10s)
- `curl localhost:8080/api/v1/health` returns 200 with `{"status":"ok"}`
- Data persists across `docker compose down && docker compose up -d`
- `docker images` shows scratch-based image at ~20-30MB
- All Go tests pass: `go test ./...`
</verification>

<success_criteria>
1. Application runs in a Docker container built via multi-stage scratch build with zero CGO dependency
2. SQLite data persists across container restarts via Docker named volume
3. `docker compose up` starts the full application with a single command
4. API is accessible on localhost:8080 from the host machine
5. Docker HEALTHCHECK reports container as healthy
</success_criteria>

<output>
After completion, create `.planning/phases/06-docker-deployment/06-01-SUMMARY.md`
</output>
