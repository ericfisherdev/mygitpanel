---
phase: 06-docker-deployment
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/application/adaptive.go
  - internal/application/adaptive_test.go
  - internal/application/pollservice.go
  - internal/application/pollservice_test.go
autonomous: true

must_haves:
  truths:
    - "Recently active repos are polled more frequently than stale repos"
    - "A repo with PR activity in the last hour polls every 2 minutes"
    - "A repo with no activity for 7+ days polls every 30 minutes"
    - "Manual refresh via API resets a repo's schedule to poll immediately"
    - "Tier assignments are logged for observability"
  artifacts:
    - path: "internal/application/adaptive.go"
      provides: "ActivityTier type, tier classification, repoSchedule, tier intervals"
      exports: ["ActivityTier", "TierHot", "TierActive", "TierWarm", "TierStale"]
      min_lines: 40
    - path: "internal/application/adaptive_test.go"
      provides: "Tests for tier classification and schedule management"
      min_lines: 30
    - path: "internal/application/pollservice.go"
      provides: "Adaptive polling loop replacing fixed ticker"
      contains: "pollDueRepos"
  key_links:
    - from: "internal/application/pollservice.go"
      to: "internal/application/adaptive.go"
      via: "classifyActivity and repoSchedule usage"
      pattern: "classifyActivity"
    - from: "internal/application/pollservice.go"
      to: "driven.PRStore.GetByRepository"
      via: "query PRs to find freshest LastActivityAt per repo"
      pattern: "prStore\\.GetByRepository"
---

<objective>
Replace the fixed-interval polling ticker with an adaptive scheduler that adjusts per-repository polling frequency based on PR activity. Hot repos (activity < 1h) poll every 2 minutes; stale repos (activity >= 7d) poll every 30 minutes.

Purpose: Fulfills POLL-03 (adaptive polling -- active PRs polled more frequently, stale ones less). Reduces GitHub API rate limit consumption by 50-70% for mixed-activity repo sets while keeping active PRs fresh.
Output: internal/application/adaptive.go, adaptive_test.go, updated pollservice.go with adaptive loop.
</objective>

<execution_context>
@/home/esfisher/.claude/get-shit-done/workflows/execute-plan.md
@/home/esfisher/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-docker-deployment/06-RESEARCH.md

@internal/application/pollservice.go
@internal/application/pollservice_test.go
@internal/domain/port/driven/prstore.go
@internal/domain/port/driven/repostore.go
@internal/domain/model/pullrequest.go
@internal/domain/model/repository.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Activity tier classification and schedule types</name>
  <files>
    internal/application/adaptive.go
    internal/application/adaptive_test.go
  </files>
  <action>
    1. Create `internal/application/adaptive.go`:

       **ActivityTier type** (exported typed int):
       ```
       TierHot    = 0  // Last activity < 1 hour  -> poll every 2 minutes
       TierActive = 1  // Last activity < 1 day   -> poll every 5 minutes
       TierWarm   = 2  // Last activity < 7 days  -> poll every 15 minutes
       TierStale  = 3  // Last activity >= 7 days -> poll every 30 minutes
       ```

       **tierInterval function** (unexported, returns time.Duration for a tier):
       Map each tier to its polling interval. Default to 5 minutes for unknown tiers.

       **classifyActivity function** (unexported, takes time.Time, returns ActivityTier):
       Classify based on `time.Since(lastActivity)`:
       - < 1 hour -> TierHot
       - < 24 hours -> TierActive
       - < 7 days -> TierWarm
       - >= 7 days -> TierStale

       **repoSchedule struct** (unexported):
       Fields: `tier ActivityTier`, `nextPollAt time.Time`, `lastPolled time.Time`

       **String() method on ActivityTier** for readable log output:
       Return "hot", "active", "warm", "stale" respectively.

       **freshestActivity function** (unexported, takes []model.PullRequest, returns time.Time):
       Find the most recent `LastActivityAt` across all PRs. If the slice is empty, return `time.Time{}` (zero value), which will classify as TierStale. This function is used by the scheduler to determine a repo's tier from its PRs.

    2. Create `internal/application/adaptive_test.go`:

       **Test classifyActivity**: Table-driven test with cases:
       - 30 minutes ago -> TierHot
       - 59 minutes ago -> TierHot (boundary)
       - 61 minutes ago -> TierActive (boundary)
       - 12 hours ago -> TierActive
       - 25 hours ago -> TierWarm
       - 3 days ago -> TierWarm
       - 8 days ago -> TierStale

       **Test tierInterval**: Each tier returns expected duration (2m, 5m, 15m, 30m).

       **Test freshestActivity**:
       - Empty slice returns zero time
       - Multiple PRs returns the most recent LastActivityAt
       - Single PR returns its LastActivityAt

       **Test ActivityTier.String()**: Each tier has human-readable name.
  </action>
  <verify>
    - `go test -v -run "TestClassify|TestTier|TestFreshest" ./internal/application/...` passes
    - `go vet ./internal/application/...` reports no issues
  </verify>
  <done>
    ActivityTier type with 4 tiers exists. classifyActivity maps time.Since() to tiers with correct boundaries. tierInterval maps each tier to its polling duration. freshestActivity finds most recent LastActivityAt across PRs. repoSchedule struct holds per-repo scheduling state. All tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate adaptive scheduling into PollService</name>
  <files>
    internal/application/pollservice.go
    internal/application/pollservice_test.go
  </files>
  <action>
    1. Add a `schedules map[string]repoSchedule` field to the PollService struct.
       Initialize it in NewPollService as an empty map.

    2. Add an `updateSchedule` method on PollService:
       - Call `s.prStore.GetByRepository(ctx, repoFullName)` to get all PRs for the repo.
       - Call `freshestActivity(prs)` to find the most recent activity.
       - Call `classifyActivity(freshestActivity)` to determine the tier.
       - Set `s.schedules[repoFullName] = repoSchedule{tier: tier, nextPollAt: time.Now().Add(tierInterval(tier)), lastPolled: time.Now()}`
       - Log the tier assignment: `slog.Info("repo tier updated", "repo", repoFullName, "tier", tier.String(), "next_poll", nextPollAt.Format(time.RFC3339))`

    3. Add a `pollDueRepos` method on PollService:
       - Reset the branchProtectionCache (same as pollAll does).
       - Call `s.repoStore.ListAll(ctx)` to get all repos.
       - For each repo:
         - Look up schedule in `s.schedules`. If not found, the repo is new -- poll it immediately.
         - If `time.Now().Before(schedule.nextPollAt)`, skip (not due yet).
         - Otherwise, call `s.pollRepo(ctx, repo.FullName)`.
         - After polling (success or failure), call `s.updateSchedule(ctx, repo.FullName)`.
       - Log summary: `slog.Info("adaptive poll cycle", "repos_checked", total, "repos_polled", polled)`

    4. Modify `Start` method:
       Replace the fixed `time.NewTicker(s.interval)` with a 1-minute resolution ticker.
       - Initial poll: keep `s.pollAll(ctx)` for the first run (polls everything and initializes schedules).
       - After initial poll, call `s.updateSchedule(ctx, repo.FullName)` for each repo to set initial tiers.
         Actually, more cleanly: after `pollAll` completes, iterate all repos from repoStore and call `updateSchedule` for each.
       - Replace `ticker.C` case: change from `s.pollAll(ctx)` to `s.pollDueRepos(ctx)`.
       - The ticker interval changes from `s.interval` to `1 * time.Minute` (minimum resolution).
       - Keep the `s.interval` field on the struct for backward compatibility (it now serves as the base/default interval for newly added repos before they get a tier).

    5. Modify `handleRefresh`:
       After `s.pollRepo(ctx, req.repoFullName)` succeeds, call `s.updateSchedule(ctx, req.repoFullName)` to recalculate the tier. This ensures manual refresh updates the schedule based on fresh activity data.

    6. Update `pollAll`:
       After polling each repo successfully, call `s.updateSchedule(ctx, repo.FullName)`. This ensures the initial poll cycle sets up all schedules.

    7. Update existing tests in `pollservice_test.go`:
       - The existing tests mock PRStore and should continue working because `GetByRepository` is already mocked.
       - If any test depends on the exact ticker interval, update it to account for the 1-minute resolution or mock the time appropriately.
       - Add a new test `TestAdaptiveScheduling` that verifies:
         a. After pollAll, schedules are populated for each repo.
         b. A repo with recent activity gets TierHot/TierActive.
         c. A repo with old activity gets TierWarm/TierStale.
       - The mock PRStore's `GetByRepository` return values should include PRs with varying `LastActivityAt` times to exercise tier classification.

    IMPORTANT: The `s.interval` field is kept on PollService for backward compatibility but the ticker now always runs at 1-minute resolution. The per-repo adaptive schedule determines WHEN each repo actually gets polled. If a caller passes a 5-minute interval, newly added repos without a schedule will still get polled within 1 minute of being added (on the next tick cycle).
  </action>
  <verify>
    - `go test -v ./internal/application/...` passes all tests (existing + new adaptive test)
    - `go vet ./internal/application/...` reports no issues
    - `go build ./...` succeeds
    - Grep confirms adaptive methods exist: `grep -n "pollDueRepos\|updateSchedule\|schedules" internal/application/pollservice.go`
  </verify>
  <done>
    PollService.Start uses 1-minute resolution ticker with per-repo adaptive scheduling. Repos are classified into Hot (2min), Active (5min), Warm (15min), or Stale (30min) tiers based on their freshest PR activity. Manual refresh recalculates tier. Tier assignments are logged. All existing and new tests pass.
  </done>
</task>

</tasks>

<verification>
- `go test -v -cover ./internal/application/...` passes with coverage on adaptive logic
- `go build ./...` compiles successfully
- PollService.Start creates a 1-minute ticker (not fixed-interval)
- pollDueRepos checks per-repo schedules before polling
- updateSchedule queries PRs and classifies repo tier
- Tier boundaries: <1h=Hot(2m), <1d=Active(5m), <7d=Warm(15m), >=7d=Stale(30m)
- Manual refresh triggers schedule recalculation
- Tier changes are logged via slog
</verification>

<success_criteria>
1. Adaptive polling adjusts frequency per repository based on PR activity age
2. Hot repos (activity < 1h) poll every 2 minutes
3. Stale repos (activity >= 7d) poll every 30 minutes
4. Manual refresh resets schedule based on fresh data
5. Tier assignments are observable in structured logs
6. All existing PollService tests continue to pass
</success_criteria>

<output>
After completion, create `.planning/phases/06-docker-deployment/06-02-SUMMARY.md`
</output>
