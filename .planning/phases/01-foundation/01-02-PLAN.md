---
phase: 01-foundation
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - internal/adapter/driven/sqlite/db.go
  - internal/adapter/driven/sqlite/migrate.go
  - internal/adapter/driven/sqlite/migrations/000001_initial_schema.up.sql
  - internal/adapter/driven/sqlite/migrations/000001_initial_schema.down.sql
  - internal/adapter/driven/sqlite/prrepo.go
  - internal/adapter/driven/sqlite/prrepo_test.go
  - internal/adapter/driven/sqlite/reporepo.go
  - internal/adapter/driven/sqlite/reporepo_test.go
autonomous: true

must_haves:
  truths:
    - "SQLite database is created on first run with WAL mode enabled"
    - "Schema migrations run automatically when RunMigrations is called"
    - "PRStore adapter can upsert, query by repo, query by status, query by number, list all, and delete pull requests"
    - "RepoStore adapter can add, remove, get by full name, and list all repositories"
    - "Foreign key cascade deletes PRs when a repository is removed"
  artifacts:
    - path: "internal/adapter/driven/sqlite/db.go"
      provides: "Dual reader/writer DB wrapper with WAL mode"
      contains: "type DB struct"
    - path: "internal/adapter/driven/sqlite/migrate.go"
      provides: "Embedded migration runner"
      contains: "go:embed"
    - path: "internal/adapter/driven/sqlite/migrations/000001_initial_schema.up.sql"
      provides: "Initial schema with repositories and pull_requests tables"
      contains: "CREATE TABLE"
    - path: "internal/adapter/driven/sqlite/prrepo.go"
      provides: "SQLite PRStore implementation"
      contains: "func (r *PRRepo)"
    - path: "internal/adapter/driven/sqlite/reporepo.go"
      provides: "SQLite RepoStore implementation"
      contains: "func (r *RepoRepo)"
  key_links:
    - from: "internal/adapter/driven/sqlite/prrepo.go"
      to: "internal/domain/port/driven/prstore.go"
      via: "implements PRStore interface"
      pattern: "var _ driven\\.PRStore = "
    - from: "internal/adapter/driven/sqlite/reporepo.go"
      to: "internal/domain/port/driven/repostore.go"
      via: "implements RepoStore interface"
      pattern: "var _ driven\\.RepoStore = "
    - from: "internal/adapter/driven/sqlite/migrate.go"
      to: "internal/adapter/driven/sqlite/migrations/"
      via: "go:embed directive"
      pattern: "go:embed migrations"
    - from: "internal/adapter/driven/sqlite/db.go"
      to: "modernc.org/sqlite"
      via: "driver import"
      pattern: "modernc.org/sqlite"
---

<objective>
Implement the SQLite persistence layer: dual reader/writer database wrapper with WAL mode, embedded schema migrations, and concrete adapters implementing the PRStore and RepoStore port interfaces with comprehensive tests.

Purpose: This is the persistence foundation. Every subsequent phase (GitHub polling, API endpoints, review intelligence) stores and retrieves data through these adapters. Getting the dual-connection pattern, WAL mode, and migration embedding right here prevents "database is locked" errors and missing-migration bugs later.
Output: SQLite DB wrapper, migration runner, initial schema, PRRepo adapter, RepoRepo adapter, and tests for both adapters.
</objective>

<execution_context>
@C:\Users\EFisher\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\EFisher\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation/01-RESEARCH.md
@.planning/phases/01-foundation/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SQLite database wrapper with WAL mode and embedded migration runner</name>
  <files>
    internal/adapter/driven/sqlite/db.go
    internal/adapter/driven/sqlite/migrate.go
    internal/adapter/driven/sqlite/migrations/000001_initial_schema.up.sql
    internal/adapter/driven/sqlite/migrations/000001_initial_schema.down.sql
  </files>
  <action>
    1. Install SQLite and migration dependencies:
       ```
       go get modernc.org/sqlite
       go get github.com/golang-migrate/migrate/v4
       go get github.com/golang-migrate/migrate/v4/database/sqlite
       go get github.com/golang-migrate/migrate/v4/source/iofs
       ```

    2. Create `internal/adapter/driven/sqlite/db.go`:
       - Import `modernc.org/sqlite` with blank identifier `_` to register the driver
       - `DB` struct with `Writer *sql.DB`, `Reader *sql.DB`, `path string`
       - `NewDB(dbPath string) (*DB, error)` function:
         - Build DSN: `file:{dbPath}?_pragma=journal_mode(WAL)&_pragma=busy_timeout(5000)&_pragma=synchronous(NORMAL)&_pragma=foreign_keys(ON)&_pragma=cache_size(-64000)`
         - Open writer: `sql.Open("sqlite", dsn)`, set `MaxOpenConns(1)`
         - Open reader: `sql.Open("sqlite", dsn)`, set `MaxOpenConns(4)`
         - Ping both to verify connections work
         - Return `*DB` or clean up on error (close writer if reader fails)
       - `Close() error` method: close reader first, then writer, return first non-nil error

    3. Create `internal/adapter/driven/sqlite/migrate.go`:
       - Place `//go:embed migrations/*.sql` directive and `var migrationsFS embed.FS` in this file
       - `RunMigrations(db *sql.DB) error` function:
         - Create iofs source driver from embedded FS with path `"migrations"`
         - Create sqlite database driver using `migratesqlite.WithInstance(db, &migratesqlite.Config{})`
         - Create migrator with `migrate.NewWithInstance("iofs", sourceDriver, "sqlite", dbDriver)`
         - Run `m.Up()` -- ignore `migrate.ErrNoChange` (not an error)
         - Wrap all errors with `fmt.Errorf` context
       - Import the CORRECT driver: `github.com/golang-migrate/migrate/v4/database/sqlite` (NOT sqlite3 -- sqlite3 requires CGO)

    4. Create migration SQL files in `internal/adapter/driven/sqlite/migrations/`:

       **000001_initial_schema.up.sql:**
       ```sql
       CREATE TABLE IF NOT EXISTS repositories (
           id INTEGER PRIMARY KEY AUTOINCREMENT,
           full_name TEXT NOT NULL UNIQUE,
           owner TEXT NOT NULL,
           name TEXT NOT NULL,
           added_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP
       );

       CREATE TABLE IF NOT EXISTS pull_requests (
           id INTEGER PRIMARY KEY AUTOINCREMENT,
           number INTEGER NOT NULL,
           repo_full_name TEXT NOT NULL,
           title TEXT NOT NULL,
           author TEXT NOT NULL,
           status TEXT NOT NULL DEFAULT 'open',
           is_draft INTEGER NOT NULL DEFAULT 0,
           url TEXT NOT NULL,
           branch TEXT NOT NULL DEFAULT '',
           base_branch TEXT NOT NULL DEFAULT '',
           labels TEXT NOT NULL DEFAULT '[]',
           opened_at DATETIME NOT NULL,
           updated_at DATETIME NOT NULL,
           last_activity_at DATETIME NOT NULL,
           created_in_db_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
           FOREIGN KEY (repo_full_name) REFERENCES repositories(full_name) ON DELETE CASCADE,
           UNIQUE(repo_full_name, number)
       );

       CREATE INDEX idx_pull_requests_repo ON pull_requests(repo_full_name);
       CREATE INDEX idx_pull_requests_status ON pull_requests(status);
       CREATE INDEX idx_pull_requests_author ON pull_requests(author);
       ```

       **000001_initial_schema.down.sql:**
       ```sql
       DROP INDEX IF EXISTS idx_pull_requests_author;
       DROP INDEX IF EXISTS idx_pull_requests_status;
       DROP INDEX IF EXISTS idx_pull_requests_repo;
       DROP TABLE IF EXISTS pull_requests;
       DROP TABLE IF EXISTS repositories;
       ```

    CRITICAL: Use `database/sqlite` driver for golang-migrate (NOT `database/sqlite3`). The `sqlite3` driver requires CGO.
    CRITICAL: Migration files go INSIDE the sqlite adapter directory alongside migrate.go so the `//go:embed` relative path works.
    CRITICAL: Set pragmas via DSN `_pragma=` parameters (NOT via `db.Exec("PRAGMA ...")`), so they apply to every connection in the pool.
  </action>
  <verify>
    Run `go build ./internal/adapter/driven/sqlite/...` -- must compile with no errors.
    Run `go vet ./internal/adapter/driven/sqlite/...` -- must pass.
    Verify `modernc.org/sqlite` appears in go.sum (NOT `mattn/go-sqlite3`).
    Verify `golang-migrate/migrate/v4/database/sqlite` is imported (NOT sqlite3).
  </verify>
  <done>
    DB wrapper creates dual reader/writer connections with WAL mode via DSN pragmas. Migration runner embeds SQL files and applies them on startup. Initial schema creates repositories and pull_requests tables with proper indexes and foreign key constraints. Everything compiles without CGO.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement PRRepo and RepoRepo SQLite adapters with tests</name>
  <files>
    internal/adapter/driven/sqlite/prrepo.go
    internal/adapter/driven/sqlite/prrepo_test.go
    internal/adapter/driven/sqlite/reporepo.go
    internal/adapter/driven/sqlite/reporepo_test.go
  </files>
  <action>
    1. Create `internal/adapter/driven/sqlite/reporepo.go`:
       - `RepoRepo` struct with `db *DB` field
       - `NewRepoRepo(db *DB) *RepoRepo` constructor
       - Compile-time interface check: `var _ driven.RepoStore = (*RepoRepo)(nil)`
       - Implement all `RepoStore` methods:
         - `Add(ctx, repo)`: INSERT into repositories (full_name, owner, name, added_at). Use writer.
         - `Remove(ctx, fullName)`: DELETE FROM repositories WHERE full_name=?. Use writer. Return error if not found (check RowsAffected).
         - `GetByFullName(ctx, fullName)`: SELECT * WHERE full_name=?. Use reader. Return nil, nil if not found (no error).
         - `ListAll(ctx)`: SELECT * ordered by full_name. Use reader.
       - Map between domain `model.Repository` and SQL columns in each method. Do NOT use struct tags.

    2. Create `internal/adapter/driven/sqlite/prrepo.go`:
       - `PRRepo` struct with `db *DB` field
       - `NewPRRepo(db *DB) *PRRepo` constructor
       - Compile-time interface check: `var _ driven.PRStore = (*PRRepo)(nil)`
       - Implement all `PRStore` methods:
         - `Upsert(ctx, pr)`: INSERT OR REPLACE into pull_requests. Use writer. Serialize `Labels` as JSON string for the `labels` TEXT column (use `encoding/json`).
         - `GetByRepository(ctx, repoFullName)`: SELECT WHERE repo_full_name=? ORDER BY number. Use reader. Deserialize labels JSON.
         - `GetByStatus(ctx, status)`: SELECT WHERE status=? ORDER BY updated_at DESC. Use reader.
         - `GetByNumber(ctx, repoFullName, number)`: SELECT WHERE repo_full_name=? AND number=?. Use reader. Return nil, nil if not found.
         - `ListAll(ctx)`: SELECT * ORDER BY updated_at DESC. Use reader.
         - `Delete(ctx, repoFullName, number)`: DELETE WHERE repo_full_name=? AND number=?. Use writer. Return error if not found.
       - For `Labels []string` <-> `TEXT` column: marshal to JSON on write, unmarshal on read. Store as `"[]"` if empty (NOT NULL constraint).

    3. Create test helper function `setupTestDB(t *testing.T) *DB`:
       - Create in-memory SQLite: `NewDB(":memory:")` or use a temp file path via `t.TempDir()`
       - Note: In-memory dual connections may not share data (each `sql.Open` to `:memory:` creates a separate database). Use a temp file instead: `filepath.Join(t.TempDir(), "test.db")`
       - Run migrations on the writer
       - Return the DB, use `t.Cleanup(func() { db.Close() })`

    4. Create `internal/adapter/driven/sqlite/reporepo_test.go`:
       - `TestRepoRepo_Add` -- add a repo, verify it can be retrieved by full name
       - `TestRepoRepo_Add_Duplicate` -- add same repo twice, verify error (UNIQUE constraint)
       - `TestRepoRepo_Remove` -- add then remove, verify ListAll returns empty
       - `TestRepoRepo_Remove_NotFound` -- remove non-existent repo, verify error
       - `TestRepoRepo_ListAll` -- add 3 repos, verify all returned in order
       - `TestRepoRepo_GetByFullName_NotFound` -- query non-existent, verify nil result (no error)

    5. Create `internal/adapter/driven/sqlite/prrepo_test.go`:
       - `TestPRRepo_Upsert_Insert` -- upsert a PR, verify retrievable by number
       - `TestPRRepo_Upsert_Update` -- upsert same PR twice with changed title, verify updated
       - `TestPRRepo_GetByRepository` -- add 3 PRs across 2 repos, verify filtered correctly
       - `TestPRRepo_GetByStatus` -- add PRs with different statuses, verify filtered
       - `TestPRRepo_GetByNumber_NotFound` -- query non-existent, verify nil result
       - `TestPRRepo_ListAll` -- add several PRs, verify all returned
       - `TestPRRepo_Delete` -- add then delete, verify gone
       - `TestPRRepo_Labels` -- upsert PR with labels, verify labels round-trip correctly
       - `TestPRRepo_CascadeDelete` -- add repo + PRs, remove repo, verify PRs also deleted
       - Each PR test must first add the parent repository (foreign key constraint).

    Use `testify/assert` and `testify/require` for assertions throughout tests.
  </action>
  <verify>
    Run `go test ./internal/adapter/driven/sqlite/ -v` -- all tests pass.
    Run `go vet ./internal/adapter/driven/sqlite/` -- no errors.
    Verify compile-time interface checks exist (var _ driven.PRStore / driven.RepoStore).
  </verify>
  <done>
    PRRepo implements all 6 PRStore methods with proper reader/writer separation and labels JSON serialization. RepoRepo implements all 4 RepoStore methods. All 15+ test cases pass including cascade delete, upsert-update, and not-found scenarios. Both adapters satisfy their port interfaces verified at compile time.
  </done>
</task>

</tasks>

<verification>
1. `go test ./internal/adapter/driven/sqlite/ -v` -- all adapter tests pass
2. `go vet ./internal/adapter/driven/sqlite/` -- clean
3. Compile-time interface satisfaction: `var _ driven.PRStore = (*PRRepo)(nil)` compiles
4. Compile-time interface satisfaction: `var _ driven.RepoStore = (*RepoRepo)(nil)` compiles
5. No `mattn/go-sqlite3` in go.sum (pure Go only)
6. WAL mode is enabled via DSN pragma (not db.Exec)
7. Writer uses `MaxOpenConns(1)`, reader uses `MaxOpenConns(4)`
</verification>

<success_criteria>
- DB wrapper creates dual connections with WAL mode via DSN pragmas
- Migrations embed SQL files and run successfully on startup
- PRRepo passes all tests (upsert, query by repo/status/number, list, delete, labels round-trip, cascade)
- RepoRepo passes all tests (add, remove, get, list, duplicate detection, not-found)
- Both adapters satisfy port interfaces at compile time
- Zero CGO dependencies
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-02-SUMMARY.md`
</output>
