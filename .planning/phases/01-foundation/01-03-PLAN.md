---
phase: 01-foundation
plan: 03
type: execute
wave: 3
depends_on: ["01-01", "01-02"]
files_modified:
  - cmd/reviewhub/main.go
autonomous: true

must_haves:
  truths:
    - "Application starts, loads config, opens database, runs migrations, and waits for shutdown signal"
    - "Application fails fast with clear error if REVIEWHUB_GITHUB_TOKEN is missing"
    - "Application fails fast with clear error if REVIEWHUB_GITHUB_USERNAME is missing"
    - "Application shuts down gracefully on SIGTERM/SIGINT -- closes database and exits cleanly"
    - "go build produces a working binary that can be executed"
  artifacts:
    - path: "cmd/reviewhub/main.go"
      provides: "Composition root wiring config, database, migrations, and shutdown"
      contains: "func main()"
      min_lines: 40
  key_links:
    - from: "cmd/reviewhub/main.go"
      to: "internal/config/config.go"
      via: "config.Load() call"
      pattern: "config\\.Load"
    - from: "cmd/reviewhub/main.go"
      to: "internal/adapter/driven/sqlite/db.go"
      via: "sqlite.NewDB() call"
      pattern: "sqlite\\.NewDB"
    - from: "cmd/reviewhub/main.go"
      to: "internal/adapter/driven/sqlite/migrate.go"
      via: "sqlite.RunMigrations() call"
      pattern: "sqlite\\.RunMigrations"
    - from: "cmd/reviewhub/main.go"
      to: "os/signal"
      via: "signal.NotifyContext for graceful shutdown"
      pattern: "signal\\.NotifyContext"
---

<objective>
Create the application composition root (main.go) that wires together configuration, database, migrations, and graceful shutdown into a running application.

Purpose: This is the entry point that ties all Phase 1 components together. It proves the hexagonal architecture works end-to-end: config loads, database opens with WAL mode, migrations run, adapters are instantiated, and the app shuts down cleanly on signal. This binary will be extended in subsequent phases to add the HTTP server and polling engine.
Output: Working `cmd/reviewhub/main.go` that compiles into an executable binary.
</objective>

<execution_context>
@C:\Users\EFisher\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\EFisher\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation/01-RESEARCH.md
@.planning/phases/01-foundation/01-01-SUMMARY.md
@.planning/phases/01-foundation/01-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create composition root with config, database, migrations, and graceful shutdown</name>
  <files>
    cmd/reviewhub/main.go
  </files>
  <action>
    Create `cmd/reviewhub/main.go` following the Pattern 6 (Graceful Shutdown Orchestration) from research.

    Structure:
    ```
    package main

    func main() {
        if err := run(); err != nil {
            slog.Error("fatal error", "error", err)
            os.Exit(1)
        }
    }

    func run() error {
        // 1. Load configuration (fail fast)
        // 2. Setup signal-based context (SIGINT, SIGTERM)
        // 3. Open database (dual reader/writer)
        // 4. Run migrations (on writer connection)
        // 5. Wire adapters (PRRepo, RepoRepo) -- instantiated but not yet used, future phases add services
        // 6. Log startup complete
        // 7. Wait for shutdown signal (<-ctx.Done())
        // 8. Graceful shutdown with 10s timeout
        // 9. Log shutdown complete
    }
    ```

    Implementation details:
    - Use `log/slog` for all logging (structured, leveled)
    - Use `signal.NotifyContext(context.Background(), os.Interrupt, syscall.SIGTERM)` for shutdown signal
    - `defer stop()` immediately after creating signal context
    - `defer db.Close()` immediately after opening database
    - After migrations, instantiate adapters:
      ```go
      prStore := sqliteadapter.NewPRRepo(db)
      repoStore := sqliteadapter.NewRepoRepo(db)
      _ = prStore    // Used in Phase 2+ when services are added
      _ = repoStore  // Used in Phase 2+ when services are added
      ```
    - Log meaningful startup info: listen addr, db path (NOT the token -- security)
    - After `<-ctx.Done()`, create shutdown context with 10s timeout for future HTTP server graceful drain
    - Log "shutdown complete" before returning nil

    Import alias the sqlite package to avoid collision:
    ```go
    sqliteadapter "github.com/efisher/reviewhub/internal/adapter/driven/sqlite"
    ```

    CRITICAL: Do NOT log the GitHub token. Log the username for debugging but mask the token.
    CRITICAL: Use `os.Exit(1)` in main() only, not in run(). The run() function returns errors so defers execute properly.
  </action>
  <verify>
    1. Run `go build -o reviewhub.exe ./cmd/reviewhub/` -- must produce binary with no errors.
    2. Run `go vet ./cmd/reviewhub/` -- must pass.
    3. Test fail-fast: Run without env vars set -- must exit with error mentioning REVIEWHUB_GITHUB_TOKEN.
    4. Test startup: Set REVIEWHUB_GITHUB_TOKEN=test and REVIEWHUB_GITHUB_USERNAME=testuser, run binary -- must log "config loaded" and "migrations complete", then wait for signal.
    5. Test shutdown: Send SIGINT (Ctrl+C) while running -- must log "shutting down" and "shutdown complete", then exit cleanly.
    6. Verify SQLite DB file is created with WAL mode: check that `reviewhub.db`, `reviewhub.db-wal`, and `reviewhub.db-shm` files exist after first run.
    7. Clean up: delete test database files and built binary after verification.
  </verify>
  <done>
    Binary compiles and runs. Missing env vars produce clear error and immediate exit. With valid env vars, app starts, creates DB with WAL mode, runs migrations, logs startup, waits for signal, and shuts down gracefully on SIGINT/SIGTERM with clean exit code 0.
  </done>
</task>

<task type="auto">
  <name>Task 2: Run full test suite and verify complete phase</name>
  <files></files>
  <action>
    Run the complete test suite for all Phase 1 packages to verify everything works together:

    1. Run all tests:
       ```
       go test ./... -v -count=1
       ```
       All tests must pass: config tests (6 cases) and adapter tests (15+ cases).

    2. Run vet on entire project:
       ```
       go vet ./...
       ```
       Must be clean.

    3. Verify the hexagonal dependency rule by inspecting imports:
       - `internal/domain/model/` -- ONLY stdlib `time`
       - `internal/domain/port/driven/` -- ONLY stdlib `context` and internal `model` package
       - `internal/adapter/driven/sqlite/` -- Can import domain model, domain port, and external libs
       - `internal/config/` -- ONLY stdlib
       - `cmd/reviewhub/` -- Can import everything (composition root)

    4. Run a quick build to verify no compilation issues:
       ```
       go build ./...
       ```

    5. Verify no CGO dependency:
       ```
       CGO_ENABLED=0 go build ./cmd/reviewhub/
       ```
       Must succeed (pure Go build without CGO).

    If any test fails or vet reports issues, fix them before completing.
  </action>
  <verify>
    `go test ./... -v -count=1` -- all tests pass (0 failures).
    `go vet ./...` -- clean output.
    `CGO_ENABLED=0 go build ./cmd/reviewhub/` -- succeeds.
  </verify>
  <done>
    All Phase 1 tests pass. Project builds with CGO_ENABLED=0 (pure Go). Hexagonal dependency rule holds: domain layer has zero external imports, adapters implement port interfaces, composition root wires everything. Phase 1 success criteria fully met.
  </done>
</task>

</tasks>

<verification>
1. `go test ./... -v -count=1` -- all tests pass across config and adapter packages
2. `go vet ./...` -- zero issues
3. `CGO_ENABLED=0 go build ./cmd/reviewhub/` -- produces working binary without CGO
4. Binary starts with valid env vars, creates WAL-mode SQLite DB, runs migrations, waits for signal
5. Binary exits cleanly on SIGINT/SIGTERM
6. Binary fails fast with descriptive error when required env vars are missing
7. Domain layer imports only stdlib types
</verification>

<success_criteria>
- main.go compiles and produces a working binary
- Fail-fast config validation works (missing token/username causes immediate exit with clear error)
- Database created on first run with WAL mode (wal and shm files present)
- Migrations run automatically on startup
- Graceful shutdown on SIGTERM/SIGINT closes database and exits cleanly
- Full test suite passes (20+ tests across 2 packages)
- Builds with CGO_ENABLED=0 (no CGO dependency)
- All 5 Phase 1 success criteria from ROADMAP.md are met
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-03-SUMMARY.md`
</output>
