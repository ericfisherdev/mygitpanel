---
phase: 02-github-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - go.mod
  - go.sum
  - internal/adapter/driven/github/client.go
  - internal/adapter/driven/github/client_test.go
autonomous: true

must_haves:
  truths:
    - "GitHub adapter fetches all open PRs for a given repository with pagination"
    - "GitHub adapter maps go-github PullRequest structs to domain model.PullRequest without leaking external types"
    - "GitHub adapter uses ETag caching via httpcache transport to avoid consuming rate limits on unchanged data"
    - "GitHub adapter handles secondary rate limits via gofri/go-github-ratelimit middleware"
    - "GitHub adapter logs rate limit remaining after each API call"
    - "GitHub adapter correctly distinguishes draft PRs from ready PRs"
  artifacts:
    - path: "internal/adapter/driven/github/client.go"
      provides: "GitHubClient port implementation using go-github v82"
      exports: ["Client", "NewClient"]
    - path: "internal/adapter/driven/github/client_test.go"
      provides: "Unit tests for GitHub adapter"
      contains: "func Test"
  key_links:
    - from: "internal/adapter/driven/github/client.go"
      to: "internal/domain/port/driven/githubclient.go"
      via: "compile-time interface satisfaction check"
      pattern: "var _ driven\\.GitHubClient"
    - from: "internal/adapter/driven/github/client.go"
      to: "internal/domain/model/pullrequest.go"
      via: "mapPullRequest function"
      pattern: "model\\.PullRequest"
---

<objective>
Create the GitHub API adapter that implements the `GitHubClient` driven port using google/go-github v82. This adapter is the hexagonal boundary between the domain and GitHub's REST API. It handles pagination, ETag-based conditional requests, rate limit middleware, and maps go-github types to domain model types. No go-github types leak past this adapter.

Purpose: This is the data ingestion layer -- without it, the system cannot fetch PR data from GitHub. The transport stack (httpcache + rate limiter) ensures the system respects GitHub API limits and minimizes unnecessary API consumption.

Output: A working `internal/adapter/driven/github/client.go` implementing `FetchPullRequests` with full pagination, transport stack wiring, and domain model mapping. Plus unit tests verifying the adapter behavior.
</objective>

<execution_context>
@C:\Users\EFisher\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\EFisher\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-github-integration/02-RESEARCH.md

@internal/domain/port/driven/githubclient.go
@internal/domain/model/pullrequest.go
@internal/domain/model/enums.go
@internal/domain/model/review.go
@internal/domain/model/reviewcomment.go
@go.mod
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install dependencies and create GitHub adapter</name>
  <files>
    go.mod
    go.sum
    internal/adapter/driven/github/client.go
  </files>
  <action>
    **Step 1: Install dependencies.**
    Run:
    ```bash
    go get github.com/google/go-github/v82
    go get github.com/gregjones/httpcache
    go get github.com/gofri/go-github-ratelimit/v2
    ```

    **Step 2: Create `internal/adapter/driven/github/client.go`.**

    Package: `github` (import alias `gh` for the go-github package to avoid collision).

    **Struct:**
    ```go
    type Client struct {
        gh       *gh.Client
        username string
    }
    ```

    **Constructor `NewClient(token, username string) *Client`:**
    Build the HTTP transport stack in this order:
    1. `httpcache.NewMemoryCacheTransport()` -- transparent ETag-based HTTP caching (in-memory, rebuilt on restart which is fine since we re-poll on startup)
    2. `github_ratelimit.NewClient(cacheTransport.Client())` -- secondary rate limit middleware that sleeps on 429/Retry-After instead of erroring
    3. `gh.NewClient(rateLimitClient).WithAuthToken(token)` -- go-github client with PAT auth

    Do NOT use `oauth2.NewClient` -- `WithAuthToken()` is simpler and the current recommendation.

    **Compile-time interface check:**
    ```go
    var _ driven.GitHubClient = (*Client)(nil)
    ```

    **Method: `FetchPullRequests(ctx context.Context, repoFullName string) ([]model.PullRequest, error)`**
    - Split `repoFullName` into owner/repo using `strings.SplitN(fullName, "/", 2)`. Return error if split does not produce 2 parts.
    - Create `gh.PullRequestListOptions` with `State: "open"`, `Sort: "updated"`, `Direction: "desc"`, `ListOptions: gh.ListOptions{PerPage: 100}`.
    - Manual pagination loop: call `c.gh.PullRequests.List(ctx, owner, repo, opts)`, collect results, check `resp.NextPage == 0` to break, else set `opts.Page = resp.NextPage`.
    - After each API call, log rate limit status via `slog.Debug` with keys: `endpoint`, `page`, `count`, `rate_remaining`, `rate_limit`. If `resp.Rate.Remaining < 100`, log a `slog.Warn` with `remaining` and `reset_in` (time until reset).
    - Map each `*gh.PullRequest` to `model.PullRequest` using a `mapPullRequest` function.
    - Return the accumulated slice.

    **Method: `FetchReviews` and `FetchReviewComments`** -- stub implementations that return `nil, nil` (Phase 4 concern). These must exist to satisfy the interface.

    **Function: `mapPullRequest(pr *gh.PullRequest, repoFullName string) model.PullRequest`**
    Use ONLY `GetXxx()` helper methods on go-github pointers to avoid nil panics:
    - `Number`: `pr.GetNumber()`
    - `RepoFullName`: pass through from caller
    - `Title`: `pr.GetTitle()`
    - `Author`: `pr.GetUser().GetLogin()`
    - `Status`: if `pr.GetMergedAt()` is non-nil and non-zero -> `PRStatusMerged`, else if `pr.GetState() == "closed"` -> `PRStatusClosed`, else `PRStatusOpen`
    - `IsDraft`: `pr.GetDraft()`
    - `URL`: `pr.GetHTMLURL()`
    - `Branch`: `pr.GetHead().GetRef()`
    - `BaseBranch`: `pr.GetBase().GetRef()`
    - `Labels`: iterate `pr.Labels`, call `l.GetName()` for each. Initialize slice with `make([]string, 0, len(pr.Labels))` so empty is `[]` not `nil`.
    - `OpenedAt`: `pr.GetCreatedAt().Time`
    - `UpdatedAt`: `pr.GetUpdatedAt().Time`
    - `LastActivityAt`: `pr.GetUpdatedAt().Time` (same as UpdatedAt for now)

    **Function: `splitRepo(fullName string) (string, string, error)`**
    Split on "/" and validate 2 parts. Return `("", "", fmt.Errorf("invalid repo name %q: expected owner/repo", fullName))` if invalid.

    **Imports to use:**
    - `gh "github.com/google/go-github/v82/github"` (import alias)
    - `"github.com/gregjones/httpcache"`
    - `"github.com/gofri/go-github-ratelimit/v2/github_ratelimit"`
    - `"github.com/efisher/reviewhub/internal/domain/model"`
    - `"github.com/efisher/reviewhub/internal/domain/port/driven"`
  </action>
  <verify>
    Run `go build ./...` -- must compile with zero errors.
    Run `go vet ./...` -- must pass with zero warnings.
    Verify the compile-time interface check: `var _ driven.GitHubClient = (*Client)(nil)` compiles.
  </verify>
  <done>
    `internal/adapter/driven/github/client.go` exists, implements all 3 methods of `GitHubClient` interface (FetchPullRequests fully, FetchReviews and FetchReviewComments as stubs), compiles cleanly, and `go vet` passes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Unit tests for GitHub adapter</name>
  <files>
    internal/adapter/driven/github/client_test.go
  </files>
  <action>
    Create `internal/adapter/driven/github/client_test.go` in package `github_test` (external test package).

    Use `net/http/httptest` to create a mock GitHub API server. The test server returns JSON responses that match the GitHub API structure for `GET /repos/{owner}/{repo}/pulls`.

    **Test helpers:**
    - `newTestClient(t *testing.T, handler http.Handler) *github.Client` -- creates an httptest.Server, constructs a go-github client pointing at it (using `gh.NewClient(httpClient).WithAuthToken("test-token")` where `httpClient.Transport` points at the test server), wraps in our `Client` struct. The test must be able to construct the Client with a custom go-github client -- either export a `NewClientWithGH` constructor or make the `gh` field accessible for testing. Recommended: add an unexported constructor `newClient(ghClient *gh.Client, username string) *Client` that the test package can access via `github.NewClientForTest` exported function, or simply test via the public `NewClient` constructor by overriding the HTTP client's base URL.

    Actually, the simplest approach: use go-github's built-in test helper. go-github provides a way to set the base URL: `client.BaseURL, _ = url.Parse(server.URL + "/")`. So create a function in the test that constructs our Client struct by building a go-github client with a custom base URL pointing at httptest.Server.

    To enable this, add an exported constructor to client.go:
    ```go
    // NewClientWithHTTPClient creates a Client with a custom http.Client (for testing).
    func NewClientWithHTTPClient(httpClient *http.Client, baseURL, username string) (*Client, error) {
        client := gh.NewClient(httpClient)
        u, err := url.Parse(baseURL)
        if err != nil {
            return nil, err
        }
        client.BaseURL = u
        return &Client{gh: client, username: username}, nil
    }
    ```

    **Tests to write:**

    1. `TestFetchPullRequests_SinglePage` -- Server returns 2 PRs on a single page (no Link header). Assert: returns 2 model.PullRequest values, fields mapped correctly (Number, Title, Author, IsDraft, Status, Branch, BaseBranch, Labels, URL).

    2. `TestFetchPullRequests_Pagination` -- Server returns page 1 with a `Link: <url?page=2>; rel="next"` header and 1 PR, page 2 with 1 PR and no next link. Assert: returns 2 PRs total (both pages collected).

    3. `TestFetchPullRequests_DraftDetection` -- Server returns 1 draft PR (`"draft": true`) and 1 non-draft PR (`"draft": false`). Assert: first has `IsDraft: true`, second has `IsDraft: false`.

    4. `TestFetchPullRequests_EmptyRepo` -- Server returns empty array `[]`. Assert: returns empty slice (not nil), no error.

    5. `TestFetchPullRequests_InvalidRepoName` -- Call with "invalid" (no slash). Assert: returns error containing "invalid repo name".

    6. `TestMapPullRequest_StatusMapping` -- Test that closed PRs map to PRStatusClosed, merged PRs (with merged_at timestamp) map to PRStatusMerged, open PRs map to PRStatusOpen. This can be done via the full FetchPullRequests flow with different server responses.

    **JSON response format for test server:**
    ```json
    [
      {
        "number": 42,
        "title": "Add feature",
        "state": "open",
        "draft": false,
        "html_url": "https://github.com/owner/repo/pull/42",
        "user": {"login": "testuser"},
        "head": {"ref": "feature-branch"},
        "base": {"ref": "main"},
        "labels": [{"name": "enhancement"}],
        "created_at": "2026-01-01T00:00:00Z",
        "updated_at": "2026-01-02T00:00:00Z",
        "requested_reviewers": [{"login": "reviewer1"}],
        "requested_teams": [{"slug": "team-a"}]
      }
    ]
    ```

    Use `testify/assert` for assertions (consistent with Phase 1 tests).
  </action>
  <verify>
    Run `go test ./internal/adapter/driven/github/... -v` -- all tests must pass.
    Run `go test ./... -count=1` -- entire test suite (25 existing + new) must pass.
  </verify>
  <done>
    At least 5 test cases pass covering: single page fetch, pagination, draft detection, empty repo, invalid repo name. All existing Phase 1 tests still pass (25 tests).
  </done>
</task>

</tasks>

<verification>
1. `go build ./...` compiles with zero errors
2. `go vet ./...` passes with zero warnings
3. `go test ./... -count=1` passes (all existing + new tests)
4. `internal/adapter/driven/github/client.go` has compile-time interface check `var _ driven.GitHubClient = (*Client)(nil)`
5. No go-github types imported in `internal/domain/` directories
6. FetchPullRequests handles pagination (tested)
7. Transport stack includes httpcache and rate limit middleware
</verification>

<success_criteria>
- GitHub adapter implements `GitHubClient` port with `FetchPullRequests` (paginated), `FetchReviews` (stub), `FetchReviewComments` (stub)
- Transport stack: httpcache (ETag caching) -> rate limit middleware -> go-github client
- All PR fields mapped correctly from go-github types to domain model using `GetXxx()` helpers
- Draft PRs correctly detected via `GetDraft()`
- At least 5 unit tests pass covering pagination, mapping, edge cases
- Full test suite passes (existing + new)
</success_criteria>

<output>
After completion, create `.planning/phases/02-github-integration/02-01-SUMMARY.md`
</output>
