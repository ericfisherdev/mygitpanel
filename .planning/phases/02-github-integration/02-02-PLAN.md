---
phase: 02-github-integration
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - internal/config/config.go
  - internal/config/config_test.go
  - internal/domain/model/pullrequest.go
  - internal/adapter/driven/github/client.go
  - internal/application/pollservice.go
  - internal/application/pollservice_test.go
  - cmd/reviewhub/main.go
autonomous: true

must_haves:
  truths:
    - "System polls GitHub at a configurable interval and discovers all open PRs authored by the configured user"
    - "System discovers PRs where the user or user's team is requested as reviewer"
    - "System deduplicates PRs that appear in both authored and review-requested queries via upsert"
    - "System correctly distinguishes draft PRs from ready PRs during discovery"
    - "A manual refresh can be triggered for a specific repository bypassing the polling interval"
    - "System tracks updated_at timestamps to skip re-processing unchanged PRs"
    - "Polling stops cleanly on context cancellation (SIGTERM/SIGINT)"
    - "Stale PRs (previously open but no longer in fetch results) are cleaned up"
  artifacts:
    - path: "internal/application/pollservice.go"
      provides: "Polling engine with PR discovery, filtering, deduplication, and manual refresh"
      exports: ["PollService", "NewPollService"]
    - path: "internal/application/pollservice_test.go"
      provides: "Unit tests for poll service filtering and discovery logic"
      contains: "func Test"
    - path: "internal/config/config.go"
      provides: "Updated config with REVIEWHUB_GITHUB_TEAMS env var"
      contains: "GitHubTeams"
    - path: "cmd/reviewhub/main.go"
      provides: "Composition root wiring GitHub client and poll service"
      contains: "pollservice"
  key_links:
    - from: "internal/application/pollservice.go"
      to: "internal/domain/port/driven/githubclient.go"
      via: "driven.GitHubClient dependency injection"
      pattern: "driven\\.GitHubClient"
    - from: "internal/application/pollservice.go"
      to: "internal/domain/port/driven/prstore.go"
      via: "driven.PRStore dependency injection"
      pattern: "driven\\.PRStore"
    - from: "internal/application/pollservice.go"
      to: "internal/domain/port/driven/repostore.go"
      via: "driven.RepoStore dependency injection"
      pattern: "driven\\.RepoStore"
    - from: "cmd/reviewhub/main.go"
      to: "internal/application/pollservice.go"
      via: "NewPollService constructor call"
      pattern: "application\\.NewPollService"
    - from: "cmd/reviewhub/main.go"
      to: "internal/adapter/driven/github/client.go"
      via: "github.NewClient constructor call"
      pattern: "github\\.NewClient"
---

<objective>
Create the polling engine (application service) that orchestrates PR discovery on a configurable interval, filters PRs by author and reviewer (including team review requests), deduplicates via upsert, supports manual refresh, and cleans up stale PRs. Wire everything into the composition root so the application actually polls GitHub on startup.

Purpose: This is the core orchestration layer -- it connects the GitHub adapter (Plan 01) to the persistence layer (Phase 1) and drives the periodic data ingestion that the entire system depends on. Without this, the system has components but no behavior.

Output: A working `internal/application/pollservice.go` with tests, updated config for team slugs, and a fully wired `cmd/reviewhub/main.go` that starts polling on startup.
</objective>

<execution_context>
@C:\Users\EFisher\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\EFisher\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-github-integration/02-RESEARCH.md
@.planning/phases/02-github-integration/02-01-SUMMARY.md

@internal/domain/port/driven/githubclient.go
@internal/domain/port/driven/prstore.go
@internal/domain/port/driven/repostore.go
@internal/domain/model/pullrequest.go
@internal/domain/model/enums.go
@internal/config/config.go
@internal/config/config_test.go
@cmd/reviewhub/main.go
@internal/adapter/driven/github/client.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add teams config and create poll service</name>
  <files>
    internal/config/config.go
    internal/config/config_test.go
    internal/domain/model/pullrequest.go
    internal/adapter/driven/github/client.go
    internal/application/pollservice.go
    internal/application/pollservice_test.go
  </files>
  <action>
    **Step 1: Update `internal/config/config.go`.**

    Add a `GitHubTeams []string` field to the `Config` struct. In `Load()`, read `REVIEWHUB_GITHUB_TEAMS` as an optional comma-separated env var. If set, split on commas, trim whitespace from each slug, filter out empty strings. If not set, default to empty slice `[]string{}`.

    ```go
    GitHubTeams []string
    ```

    In Load():
    ```go
    var githubTeams []string
    if v, ok := os.LookupEnv("REVIEWHUB_GITHUB_TEAMS"); ok && v != "" {
        for _, slug := range strings.Split(v, ",") {
            slug = strings.TrimSpace(slug)
            if slug != "" {
                githubTeams = append(githubTeams, slug)
            }
        }
    }
    ```

    Add `"strings"` to imports. Set `GitHubTeams: githubTeams` in the returned Config (use `githubTeams` if non-nil, else `[]string{}`).

    **Step 2: Add config test.**

    Add a test in `internal/config/config_test.go` for the teams env var:
    - `TestLoad_GitHubTeams` -- set `REVIEWHUB_GITHUB_TEAMS=team-a, team-b` (with spaces), assert `cfg.GitHubTeams` equals `[]string{"team-a", "team-b"}`.
    - `TestLoad_GitHubTeams_Empty` -- do not set the env var, assert `cfg.GitHubTeams` is empty slice or nil (either is fine).

    **Step 3: Create `internal/application/pollservice.go`.**

    Package: `application`

    **Types:**

    ```go
    // refreshRequest represents a manual refresh trigger.
    type refreshRequest struct {
        repoFullName string    // specific repo, or empty for all
        prNumber     int       // specific PR number, or 0 for all PRs in repo
        done         chan error // signals completion
    }

    // PollService orchestrates periodic GitHub polling, PR discovery,
    // and persistence.
    type PollService struct {
        ghClient  driven.GitHubClient
        prStore   driven.PRStore
        repoStore driven.RepoStore
        username  string
        teamSlugs []string
        interval  time.Duration
        refreshCh chan refreshRequest
    }
    ```

    **Constructor: `NewPollService(ghClient driven.GitHubClient, prStore driven.PRStore, repoStore driven.RepoStore, username string, teamSlugs []string, interval time.Duration) *PollService`**
    Initialize all fields. `refreshCh: make(chan refreshRequest)`.

    **Method: `Start(ctx context.Context)`**
    - Run `s.pollAll(ctx)` immediately on start (log error but don't return -- keep running).
    - Create `time.NewTicker(s.interval)`, defer `ticker.Stop()`.
    - Select loop on 3 channels:
      - `<-ctx.Done()` -> log "poll service stopped", return
      - `<-ticker.C` -> `s.pollAll(ctx)`, log error if any
      - `req := <-s.refreshCh` -> `req.done <- s.handleRefresh(ctx, req)`

    **Method: `RefreshRepo(ctx context.Context, repoFullName string) error`**
    Send a `refreshRequest{repoFullName: repoFullName, done: make(chan error, 1)}` on `refreshCh`. Select on `done` and `ctx.Done()`.

    **Method: `RefreshPR(ctx context.Context, repoFullName string, prNumber int) error`**
    Same pattern as RefreshRepo but with `prNumber` set. For now, this triggers a full repo poll (we don't have a single-PR fetch endpoint in the port interface). The PR number is logged for audit but the full repo is re-fetched.

    **Method: `pollAll(ctx context.Context) error`**
    - `start := time.Now()`
    - Fetch all repos via `s.repoStore.ListAll(ctx)`
    - For each repo: check `ctx.Err()` first, then call `s.pollRepo(ctx, repo.FullName)`. Log errors per-repo but continue to next (don't fail entire cycle).
    - Log completion: "poll cycle complete" with `repos` count and `duration`.

    **Method: `pollRepo(ctx context.Context, repoFullName string) error`**
    This is the core PR discovery logic:

    1. Fetch all open PRs: `prs, err := s.ghClient.FetchPullRequests(ctx, repoFullName)`
    2. Get currently stored PRs for this repo: `storedPRs, err := s.prStore.GetByRepository(ctx, repoFullName)`
    3. Build a set of fetched PR numbers (for stale detection): `fetchedNumbers := make(map[int]bool)`
    4. For each fetched PR:
       - Add PR number to `fetchedNumbers`
       - **Author filter:** `strings.EqualFold(pr.Author, s.username)`
       - **Reviewer filter:** Check if the PR has review requested from user or user's team. Since FetchPullRequests returns `model.PullRequest` (which does NOT have RequestedReviewers/RequestedTeams), we need a way to get this info.

       **IMPORTANT DESIGN DECISION:** The `model.PullRequest` does not have reviewer fields. The research noted this gap. Two options:
       - (A) Add `RequestedReviewers []string` and `RequestedTeamSlugs []string` to `model.PullRequest` -- but these are transient (not persisted, only relevant during discovery).
       - (B) Return a richer type from the adapter that includes review request metadata alongside the domain model.

       **Go with option A:** Add `RequestedReviewers []string` and `RequestedTeamSlugs []string` fields to `model.PullRequest`. These fields are populated by the GitHub adapter during mapping (from `pr.RequestedReviewers` and `pr.RequestedTeams`). They are NOT persisted to SQLite (the existing schema has no columns for them and the Upsert ignores unknown fields). They are only used during the discovery filtering step. This keeps the port interface clean (`FetchPullRequests` still returns `[]model.PullRequest`).

       So the filter logic:
       ```go
       isAuthored := strings.EqualFold(pr.Author, s.username)
       isReviewRequested := isReviewRequestedFrom(pr, s.username, s.teamSlugs)
       if !isAuthored && !isReviewRequested {
           continue // skip PRs not relevant to user
       }
       ```
       - **Skip unchanged:** Compare `pr.UpdatedAt` with stored PR's `UpdatedAt`. If identical, skip the upsert (POLL-07). Find stored PR by matching number in the storedPRs list.
       - **Upsert:** `s.prStore.Upsert(ctx, pr)` -- deduplication is inherent (same PR authored + review-requested only upserted once because we iterate once).

    5. **Stale PR cleanup:** For each stored PR whose number is NOT in `fetchedNumbers` AND whose status is "open":
       - The PR is no longer in the open PR list -- it was likely closed or merged.
       - Delete it: `s.prStore.Delete(ctx, repoFullName, storedPR.Number)`. Log the cleanup.
       - (We could re-fetch individually to check status, but for v1, deletion is simpler. The PR will reappear on next poll if it was reopened.)

    6. Log: "repo polled" with `repo`, `fetched`, `relevant` (after filter), `skipped_unchanged`, `cleaned_up` counts.

    **Helper: `isReviewRequestedFrom(pr model.PullRequest, username string, teamSlugs []string) bool`**
    - Check `pr.RequestedReviewers` for case-insensitive match with `username`
    - Check `pr.RequestedTeamSlugs` for case-insensitive match with any slug in `teamSlugs`

    **Method: `handleRefresh(ctx context.Context, req refreshRequest) error`**
    - If `req.repoFullName` is set: call `s.pollRepo(ctx, req.repoFullName)`
    - If empty: call `s.pollAll(ctx)`

    **Step 4: Update `internal/domain/model/pullrequest.go`.**

    Add two transient fields (not persisted, only used during discovery):
    ```go
    // Transient fields populated during GitHub fetch, not persisted.
    RequestedReviewers []string
    RequestedTeamSlugs []string
    ```

    **Step 5: Update the GitHub adapter's `mapPullRequest` in `internal/adapter/driven/github/client.go`.**

    Map the new fields from go-github response:
    ```go
    reviewers := make([]string, 0, len(pr.RequestedReviewers))
    for _, r := range pr.RequestedReviewers {
        reviewers = append(reviewers, r.GetLogin())
    }

    teamSlugs := make([]string, 0, len(pr.RequestedTeams))
    for _, t := range pr.RequestedTeams {
        teamSlugs = append(teamSlugs, t.GetSlug())
    }
    ```
    Set `RequestedReviewers: reviewers` and `RequestedTeamSlugs: teamSlugs` on the returned model.PullRequest.

    **Step 6: Create `internal/application/pollservice_test.go`.**

    Package: `application_test` (external test package).

    Create mock implementations of `driven.GitHubClient`, `driven.PRStore`, and `driven.RepoStore` interfaces for testing. These are simple structs with function fields or slice-based in-memory stores.

    **Tests:**

    1. `TestPollRepo_AuthoredPRs` -- Mock GitHubClient returns 3 PRs: 1 authored by user, 2 by others. Assert: only 1 PR upserted.

    2. `TestPollRepo_ReviewRequestedPRs` -- Mock returns 2 PRs: 1 with user in RequestedReviewers, 1 without. Assert: 1 PR upserted.

    3. `TestPollRepo_TeamReviewRequest` -- Mock returns 1 PR with RequestedTeamSlugs containing "my-team". PollService configured with teamSlugs ["my-team"]. Assert: PR upserted.

    4. `TestPollRepo_Deduplication` -- Mock returns 1 PR that is both authored by user AND has review requested from user. Assert: only 1 upsert call (not 2).

    5. `TestPollRepo_SkipUnchanged` -- Mock returns 1 authored PR with UpdatedAt = T1. PRStore already has this PR with UpdatedAt = T1. Assert: upsert NOT called (skipped).

    6. `TestPollRepo_DraftFlagging` -- Mock returns 1 draft PR authored by user. Assert: upserted PR has `IsDraft: true`.

    7. `TestPollRepo_StaleCleanup` -- PRStore has PR #10 for repo. Mock GitHubClient returns PRs #11 and #12 (no #10). Assert: PR #10 deleted from store.

    8. `TestIsReviewRequestedFrom` -- Unit test the helper directly. Cases: username match (case insensitive), team slug match, no match.

    Use `testify/assert` for assertions.
  </action>
  <verify>
    Run `go test ./internal/application/... -v` -- all tests must pass.
    Run `go test ./internal/config/... -v` -- all config tests (existing + new) must pass.
    Run `go test ./... -count=1` -- entire test suite must pass.
  </verify>
  <done>
    Poll service exists with Start/RefreshRepo/RefreshPR methods. PR discovery filters by author AND reviewer (individual + team). Deduplication is inherent via single iteration + upsert. Unchanged PRs skipped by UpdatedAt comparison. Stale PRs cleaned up. At least 8 poll service tests pass. Config loads REVIEWHUB_GITHUB_TEAMS.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire poll service into composition root</name>
  <files>
    cmd/reviewhub/main.go
  </files>
  <action>
    Update `cmd/reviewhub/main.go` to wire the GitHub client and poll service, replacing the placeholder adapter references.

    **Changes to `run()` function:**

    After step 5 (wire adapters), replace the `_ = prStore` / `_ = repoStore` placeholders with:

    ```go
    // 5. Wire adapters.
    prStore := sqliteadapter.NewPRRepo(db)
    repoStore := sqliteadapter.NewRepoRepo(db)

    // 6. Create GitHub client.
    ghClient := githubadapter.NewClient(cfg.GitHubToken, cfg.GitHubUsername)

    // 7. Create and start poll service.
    pollSvc := application.NewPollService(
        ghClient,
        prStore,
        repoStore,
        cfg.GitHubUsername,
        cfg.GitHubTeams,
        cfg.PollInterval,
    )
    go pollSvc.Start(ctx)

    // 8. Log startup complete.
    slog.Info("reviewhub started",
        "listen_addr", cfg.ListenAddr,
        "poll_interval", cfg.PollInterval,
        "teams", cfg.GitHubTeams,
    )
    ```

    Update imports:
    - Add `githubadapter "github.com/efisher/reviewhub/internal/adapter/driven/github"` (import alias to avoid collision with stdlib or other packages)
    - Add `"github.com/efisher/reviewhub/internal/application"`

    Remove the `_ = prStore` and `_ = repoStore` lines.

    The existing shutdown logic (`<-ctx.Done()`, shutdown context with 10s timeout) remains unchanged. When ctx is cancelled, the poll service's `Start()` method returns because it selects on `ctx.Done()`. The goroutine exits cleanly.

    Update the step numbering comments to reflect the new structure (config=1, signal=2, db=3, migrations=4, adapters=5, github client=6, poll service=7, startup log=8, wait for shutdown=9, graceful shutdown=10, shutdown log=11).
  </action>
  <verify>
    Run `go build ./cmd/reviewhub/...` -- must compile cleanly.
    Run `go vet ./...` -- must pass.
    Run `go test ./... -count=1` -- entire test suite must pass.
  </verify>
  <done>
    `cmd/reviewhub/main.go` creates a GitHub client, creates a PollService with all dependencies injected, starts polling in a goroutine, and shuts down cleanly on context cancellation. No placeholder `_ =` references remain for prStore or repoStore. Application compiles and all tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 3: Full phase verification</name>
  <!-- No files modified - this is a verification-only task that runs checks and fixes issues -->
  <files><!-- verification only - no files created or modified --></files>
  <action>
    Run the complete verification suite for Phase 2:

    1. `go build ./...` -- entire project compiles
    2. `go vet ./...` -- no warnings
    3. `go test ./... -count=1 -v` -- all tests pass (Phase 1 + Phase 2)
    4. Verify hexagonal dependency rule: `go list -f '{{ .Imports }}' ./internal/domain/model/` should NOT contain any `github.com/google/go-github` imports. `go list -f '{{ .Imports }}' ./internal/domain/port/driven/` should only contain context and domain model.
    5. Verify no go-github types leak: grep for `github.com/google/go-github` in `internal/domain/` -- should find zero matches.
    6. Count total tests: should be Phase 1 tests (25) + Phase 2 adapter tests (~5-6) + Phase 2 poll service tests (~8-10) + config tests (~2) = approximately 40+ tests.

    Log all results. If any check fails, fix it before marking complete.
  </action>
  <verify>
    All 6 verification steps pass. Total test count is 35+. Zero compilation errors, zero vet warnings, zero go-github imports in domain layer.
  </verify>
  <done>
    Phase 2 is fully verified: all tests pass, hexagonal dependency rule holds, no external type leakage into domain, application compiles and is ready for Phase 3 (HTTP endpoints).
  </done>
</task>

</tasks>

<verification>
Phase 2 success criteria from ROADMAP.md:

1. "System polls GitHub at a configurable interval (default 5 minutes) and discovers all open PRs authored by the configured user across watched repositories"
   - Verified by: PollService.Start uses time.Ticker with cfg.PollInterval, pollRepo filters by author

2. "System discovers PRs where the user (or the user's team) is requested as a reviewer, and deduplicates PRs that appear in both authored and review-requested queries"
   - Verified by: isReviewRequestedFrom checks both RequestedReviewers and RequestedTeamSlugs, single iteration prevents duplicate upserts

3. "System correctly distinguishes draft PRs from ready PRs"
   - Verified by: mapPullRequest maps pr.GetDraft() to model.IsDraft, TestDraftDetection test

4. "System tracks GitHub API rate limit budget, uses conditional requests (ETags) to avoid consuming limits on unchanged data, uses updated_at timestamps to skip re-processing, and handles pagination for all list endpoints"
   - Verified by: httpcache transport for ETags, rate limit logging in adapter, UpdatedAt comparison in pollRepo, pagination loop in FetchPullRequests

5. "A manual refresh can be triggered for a specific repository or PR, bypassing the polling interval"
   - Verified by: RefreshRepo and RefreshPR methods using refresh channel
</verification>

<success_criteria>
- Application starts, creates GitHub client with transport stack, starts polling goroutine
- Poll service fetches PRs from all watched repos on configurable interval
- PRs filtered by author match OR review request (individual + team)
- Deduplication via single-pass iteration + upsert
- Unchanged PRs skipped by UpdatedAt comparison
- Stale PRs cleaned up when no longer in open PR list
- Manual refresh available via RefreshRepo/RefreshPR methods
- REVIEWHUB_GITHUB_TEAMS config loads comma-separated team slugs
- All tests pass (40+), hexagonal dependency rule holds
- Graceful shutdown: poll service stops on context cancellation
</success_criteria>

<output>
After completion, create `.planning/phases/02-github-integration/02-02-SUMMARY.md`
</output>
