---
phase: 04-review-intelligence
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - internal/adapter/driven/github/client.go
  - internal/adapter/driven/github/client_test.go
  - internal/adapter/driven/github/graphql.go
  - internal/adapter/driven/github/graphql_test.go
  - internal/adapter/driven/sqlite/prrepo.go
autonomous: true

must_haves:
  truths:
    - "FetchReviews returns domain Review objects with CommitID, State, and IsBot populated from GitHub API"
    - "FetchReviewComments returns domain ReviewComment objects with DiffHunk, Path, Line, StartLine, SubjectType, InReplyToID, and CommitID"
    - "FetchIssueComments returns domain IssueComment objects for PR-level general comments"
    - "FetchThreadResolution returns a map of comment ID to isResolved boolean via GitHub GraphQL API"
    - "mapPullRequest populates HeadSHA from the GitHub PR response"
    - "PRRepo.Upsert persists HeadSHA to SQLite"
  artifacts:
    - path: "internal/adapter/driven/github/client.go"
      provides: "Real implementations of FetchReviews, FetchReviewComments, FetchIssueComments replacing stubs"
      contains: "ListReviews"
    - path: "internal/adapter/driven/github/graphql.go"
      provides: "Minimal GraphQL client for thread resolution"
      contains: "FetchThreadResolution"
    - path: "internal/adapter/driven/github/graphql_test.go"
      provides: "Tests for GraphQL thread resolution"
      contains: "TestFetchThreadResolution"
  key_links:
    - from: "internal/adapter/driven/github/client.go"
      to: "internal/domain/model/review.go"
      via: "mapReview function"
      pattern: "func mapReview"
    - from: "internal/adapter/driven/github/client.go"
      to: "internal/domain/model/reviewcomment.go"
      via: "mapReviewComment function"
      pattern: "func mapReviewComment"
    - from: "internal/adapter/driven/github/graphql.go"
      to: "api.github.com/graphql"
      via: "net/http POST request"
      pattern: "graphql"
---

<objective>
Implement the GitHub adapter methods for fetching reviews, review comments, issue comments, and thread resolution status. Replace the Phase 2 stubs with real API calls. Also update the PR mapping and persistence to track HeadSHA.

Purpose: Without real data flowing from GitHub, no enrichment or API output is possible. This plan connects the external data source to the domain model.
Output: 4 working GitHub adapter methods, GraphQL thread resolution, HeadSHA mapping/persistence.
</objective>

<execution_context>
@/home/esfisher/.claude/get-shit-done/workflows/execute-plan.md
@/home/esfisher/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-review-intelligence/04-RESEARCH.md
@.planning/phases/04-review-intelligence/04-01-SUMMARY.md
@internal/adapter/driven/github/client.go
@internal/adapter/driven/github/client_test.go
@internal/domain/model/review.go
@internal/domain/model/reviewcomment.go
@internal/domain/model/issuecomment.go
@internal/domain/port/driven/githubclient.go
@internal/adapter/driven/sqlite/prrepo.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement FetchReviews, FetchReviewComments, FetchIssueComments, and update HeadSHA mapping/persistence</name>
  <files>
    internal/adapter/driven/github/client.go
    internal/adapter/driven/github/client_test.go
    internal/adapter/driven/sqlite/prrepo.go
  </files>
  <action>
**Replace the 2 stub methods and add 1 new method in client.go:**

1. **FetchReviews** -- Replace the stub. Use `c.gh.PullRequests.ListReviews(ctx, owner, repo, prNumber, opts)` with pagination (same pattern as FetchPullRequests). Map each `*gh.PullRequestReview` to `model.Review` via a new `mapReview` function:
   - `ID`: `r.GetID()`
   - `PRID`: Pass prID parameter (the caller passes the database PR ID, NOT the GitHub PR number -- but since at this adapter level we don't know the DB ID, use 0 as placeholder; the poll service will set PRID before upserting). Actually, re-read the port: `FetchReviews(ctx, repoFullName, prNumber)` returns `[]model.Review` -- these are fresh from GitHub and don't have a DB-assigned PRID yet. Set `PRID: 0` (caller assigns before storing).
   - `ReviewerLogin`: `r.GetUser().GetLogin()`
   - `State`: `model.ReviewState(strings.ToLower(r.GetState()))`
   - `Body`: `r.GetBody()`
   - `CommitID`: `r.GetCommitID()`
   - `SubmittedAt`: `r.GetSubmittedAt().Time`
   - `IsBot`: `false` (bot detection happens in the enrichment service, not the adapter)
   Use `GetXxx()` helpers exclusively to avoid nil pointer panics. Handle pagination via `resp.NextPage == 0` break pattern.

2. **FetchReviewComments** -- Replace the stub. Use `c.gh.PullRequests.ListComments(ctx, owner, repo, prNumber, opts)` with pagination. Map each `*gh.PullRequestComment` to `model.ReviewComment` via a new `mapReviewComment` function:
   - `ID`: `c.GetID()`
   - `ReviewID`: `c.GetPullRequestReviewID()`
   - `PRID`: 0 (caller assigns)
   - `Author`: `c.GetUser().GetLogin()`
   - `Body`: `c.GetBody()`
   - `Path`: `c.GetPath()`
   - `Line`: `c.GetLine()` (int, 0 if absent)
   - `StartLine`: `c.GetStartLine()` (int, 0 for single-line comments)
   - `Side`: `c.GetSide()`
   - `SubjectType`: `c.GetSubjectType()` (returns "line" or "file")
   - `DiffHunk`: `c.GetDiffHunk()`
   - `CommitID`: `c.GetCommitID()`
   - `IsResolved`: `false` (set later from GraphQL data)
   - `IsOutdated`: `false` (set later by enrichment service)
   - `InReplyToID`: if `c.InReplyTo != nil` then `&inReplyTo` where `inReplyTo = c.GetInReplyTo()` (note: go-github's PullRequestComment has an `InReplyTo` field that is `*int64`). Actually check the go-github struct -- it may be named differently. The research shows `c.InReplyTo` as `*int64`. Use nil check.
   - `CreatedAt`: `c.GetCreatedAt().Time`
   - `UpdatedAt`: `c.GetUpdatedAt().Time`

3. **FetchIssueComments** -- NEW method. Use `c.gh.Issues.ListComments(ctx, owner, repo, prNumber, opts)` with pagination. Map each `*gh.IssueComment` to `model.IssueComment`:
   - `ID`: `c.GetID()`
   - `PRID`: 0 (caller assigns)
   - `Author`: `c.GetUser().GetLogin()`
   - `Body`: `c.GetBody()`
   - `IsBot`: `false` (enrichment service handles)
   - `CreatedAt`: `c.GetCreatedAt().Time`
   - `UpdatedAt`: `c.GetUpdatedAt().Time`

4. **mapPullRequest update** -- Add `HeadSHA: pr.GetHead().GetSHA()` to the PullRequest mapping in the existing `mapPullRequest` function.

5. **PRRepo.Upsert update** -- In `internal/adapter/driven/sqlite/prrepo.go`, add `head_sha` to the INSERT and ON CONFLICT UPDATE columns. Add it as a parameter in the ExecContext call. Also update `scanPR` to scan the new `head_sha` column (it's a simple TEXT field, scan directly into `pr.HeadSHA`). Update ALL SELECT queries in prrepo.go to include `head_sha` in the column list.

**Tests in client_test.go:**

Add test cases using httptest server (follow existing pattern in client_test.go):

- `TestFetchReviews`: Mock GitHub API returning 2 reviews (one approved, one changes_requested). Verify domain mapping including CommitID and State.
- `TestFetchReviewComments`: Mock returning 2 comments (one root, one reply with InReplyToID). Verify DiffHunk, Path, Line, StartLine, SubjectType mapping. Verify InReplyToID is nil for root and non-nil for reply.
- `TestFetchIssueComments`: Mock returning 1 issue comment. Verify Author, Body, timestamps.
- `TestFetchPullRequests_HeadSHA`: Verify that the existing FetchPullRequests now populates HeadSHA (add assertion to an existing test or create focused test).

**Important:** The go-github `PullRequestComment` struct's InReplyTo field -- verify the exact field name in go-github source. It may be `InReplyTo *int64` directly on the struct. Use `c.GetInReplyTo()` if available, otherwise access the field directly with nil check.
  </action>
  <verify>
`cd /home/esfisher/dev/mygitpanel && go test ./internal/adapter/driven/github/... -v -count=1` passes all tests. `go test ./internal/adapter/driven/sqlite/... -v -count=1` passes (prrepo tests still pass with head_sha). `go build ./...` compiles.
  </verify>
  <done>
FetchReviews returns reviews with CommitID and State from GitHub ListReviews API. FetchReviewComments returns comments with DiffHunk, Path, Line, StartLine, SubjectType, InReplyToID, CommitID from GitHub ListComments API. FetchIssueComments returns general PR comments from GitHub Issues ListComments API. mapPullRequest populates HeadSHA. PRRepo persists and reads HeadSHA. All 3 fetch methods handle pagination. All tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement GraphQL thread resolution client</name>
  <files>
    internal/adapter/driven/github/graphql.go
    internal/adapter/driven/github/graphql_test.go
  </files>
  <action>
**graphql.go** -- Create a minimal GraphQL client for fetching thread resolution status. This is the ONLY data that requires GraphQL (REST API does not expose isResolved).

1. Add a `token` field to the existing `Client` struct (currently only has `gh` and `username`). Update both constructors:
   - `NewClient(token, username)`: store `token` in the Client struct alongside the existing fields
   - `NewClientWithHTTPClient`: accept an optional `token` parameter (or store empty string for test mode)

   Actually, to avoid breaking the test constructor signature, add a `graphqlBaseURL` field to Client instead. In `NewClient`, set it to `"https://api.github.com/graphql"`. In `NewClientWithHTTPClient`, derive it from the provided baseURL (replace the path). The token for GraphQL auth can be extracted -- but the Client currently doesn't store the raw token. The cleanest approach: add `token string` to the Client struct. `NewClient` stores it. `NewClientWithHTTPClient` accepts it as a new parameter (or accepts "" and skips GraphQL).

   Simplest approach that avoids breaking existing tests: Add both `token string` and `graphqlURL string` to Client. `NewClient` sets both. `NewClientWithHTTPClient` gains a token parameter. If existing tests don't pass a token, update them to pass "test-token".

2. **FetchThreadResolution** method on Client:
   - If `c.token == ""`, return empty map (graceful skip for tests without tokens)
   - Build the GraphQL query (from research):
     ```graphql
     query($owner: String!, $repo: String!, $pr: Int!) {
         repository(owner: $owner, name: $repo) {
             pullRequest(number: $pr) {
                 reviewThreads(first: 100) {
                     nodes {
                         isResolved
                         comments(first: 1) {
                             nodes {
                                 databaseId
                             }
                         }
                     }
                 }
             }
         }
     }
     ```
   - Use `net/http` directly (NOT go-github) to POST to `c.graphqlURL`
   - Set headers: `Authorization: bearer {token}`, `Content-Type: application/json`
   - Request body: `{"query": "...", "variables": {"owner": "...", "repo": "...", "pr": N}}`
   - Parse response into a typed struct:
     ```go
     type graphqlResponse struct {
         Data struct {
             Repository struct {
                 PullRequest struct {
                     ReviewThreads struct {
                         Nodes []struct {
                             IsResolved bool `json:"isResolved"`
                             Comments   struct {
                                 Nodes []struct {
                                     DatabaseID int64 `json:"databaseId"`
                                 } `json:"nodes"`
                             } `json:"comments"`
                         } `json:"nodes"`
                     } `json:"reviewThreads"`
                 } `json:"pullRequest"`
             } `json:"repository"`
         } `json:"data"`
         Errors []struct {
             Message string `json:"message"`
         } `json:"errors"`
     }
     ```
   - Build the result map: for each thread node, if it has at least one comment with a databaseId, map `databaseId -> isResolved`
   - If the response has errors, log a warning and return empty map (do NOT fail the whole operation -- per research, GraphQL is supplementary)
   - If the HTTP request fails, log a warning and return empty map
   - Log `hasNextPage` warning if pagination is needed (we don't paginate initially -- `first: 100` covers most PRs)

3. Use a `graphqlHTTPClient` field (type `*http.Client`) on the Client struct for testability. Default to `http.DefaultClient` in NewClient. In `NewClientWithHTTPClient`, accept the same httpClient used for REST (or a separate one). This allows httptest injection in tests.

   Actually simplest: just use `c.gh.Client()` to get the underlying `*http.Client` from go-github for the GraphQL call. This reuses the same transport stack. But go-github's client adds auth headers via its own transport, and GraphQL needs a bearer token directly. Use a dedicated `*http.Client` with no auth transport, and add the Authorization header manually. In `NewClient`, create a plain `&http.Client{}`. In `NewClientWithHTTPClient`, accept the provided httpClient.

**graphql_test.go** -- Tests using httptest:

- `TestFetchThreadResolution_Success`: httptest server returns valid GraphQL response with 2 threads (1 resolved, 1 unresolved). Verify map has correct entries.
- `TestFetchThreadResolution_GraphQLErrors`: httptest server returns response with errors array. Verify empty map returned (no error -- graceful degradation).
- `TestFetchThreadResolution_NoToken`: Create client with empty token. Verify empty map returned immediately without making HTTP call.
- `TestFetchThreadResolution_HTTPError`: httptest server returns 500. Verify empty map returned with no panic.

**CRITICAL:** This is a supplementary data source. It MUST NOT cause failures. All error paths return empty map + log warning.
  </action>
  <verify>
`cd /home/esfisher/dev/mygitpanel && go test ./internal/adapter/driven/github/... -v -count=1` passes all tests including new GraphQL tests. `go build ./...` compiles. No new dependencies added (uses only net/http, encoding/json from stdlib).
  </verify>
  <done>
FetchThreadResolution makes a GraphQL query to GitHub, parses the response, and returns a map[int64]bool mapping comment database IDs to resolution status. It degrades gracefully on errors (returns empty map). Token and GraphQL URL are stored on Client for testability. 4 test cases cover success, GraphQL errors, no-token, and HTTP errors.
  </done>
</task>

</tasks>

<verification>
1. `go test ./internal/adapter/driven/github/... -v` passes all tests (existing + 8+ new)
2. `go test ./internal/adapter/driven/sqlite/... -v` passes all tests (prrepo tests with head_sha)
3. `go build ./...` compiles
4. `go vet ./...` passes
5. No new external dependencies added
</verification>

<success_criteria>
- FetchReviews, FetchReviewComments, FetchIssueComments are real implementations (not stubs) with pagination
- FetchThreadResolution works via GraphQL with graceful degradation
- mapPullRequest populates HeadSHA
- PRRepo persists and reads HeadSHA
- All adapter methods use GetXxx() helpers to avoid nil pointer panics
- All new code has test coverage via httptest mocks
</success_criteria>

<output>
After completion, create `.planning/phases/04-review-intelligence/04-02-SUMMARY.md`
</output>
