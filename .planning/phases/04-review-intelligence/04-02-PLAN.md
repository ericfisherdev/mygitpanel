---
phase: 04-review-intelligence
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - internal/adapter/driven/github/client.go
  - internal/adapter/driven/github/client_test.go
  - internal/adapter/driven/github/graphql.go
  - internal/adapter/driven/github/graphql_test.go
  - internal/adapter/driven/sqlite/prrepo.go
autonomous: true

must_haves:
  truths:
    - "FetchReviews returns domain Review objects with CommitID, State, and IsBot populated from GitHub API"
    - "FetchReviewComments returns domain ReviewComment objects with DiffHunk, Path, Line, StartLine, SubjectType, InReplyToID, and CommitID"
    - "FetchIssueComments returns domain IssueComment objects for PR-level general comments"
    - "FetchThreadResolution returns a map of comment ID to isResolved boolean via GitHub GraphQL API"
    - "mapPullRequest populates HeadSHA from the GitHub PR response"
    - "PRRepo.Upsert persists HeadSHA to SQLite"
  artifacts:
    - path: "internal/adapter/driven/github/client.go"
      provides: "Real implementations of FetchReviews, FetchReviewComments, FetchIssueComments replacing stubs"
      contains: "ListReviews"
    - path: "internal/adapter/driven/github/graphql.go"
      provides: "Minimal GraphQL client for thread resolution"
      contains: "FetchThreadResolution"
    - path: "internal/adapter/driven/github/graphql_test.go"
      provides: "Tests for GraphQL thread resolution"
      contains: "TestFetchThreadResolution"
  key_links:
    - from: "internal/adapter/driven/github/client.go"
      to: "internal/domain/model/review.go"
      via: "mapReview function"
      pattern: "func mapReview"
    - from: "internal/adapter/driven/github/client.go"
      to: "internal/domain/model/reviewcomment.go"
      via: "mapReviewComment function"
      pattern: "func mapReviewComment"
    - from: "internal/adapter/driven/github/graphql.go"
      to: "api.github.com/graphql"
      via: "net/http POST request"
      pattern: "graphql"
    - from: "internal/adapter/driven/github/client.go"
      to: "cmd/reviewhub/main.go"
      via: "NewClient stores token for GraphQL; NewClientWithHTTPClient accepts token parameter"
      pattern: "token string"
---

<objective>
Implement the GitHub adapter methods for fetching reviews, review comments, issue comments, and thread resolution status. Replace the Phase 2 stubs with real API calls. Also update the PR mapping and persistence to track HeadSHA.

Purpose: Without real data flowing from GitHub, no enrichment or API output is possible. This plan connects the external data source to the domain model.
Output: 4 working GitHub adapter methods, GraphQL thread resolution, HeadSHA mapping/persistence.
</objective>

<execution_context>
@/home/esfisher/.claude/get-shit-done/workflows/execute-plan.md
@/home/esfisher/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-review-intelligence/04-RESEARCH.md
@.planning/phases/04-review-intelligence/04-01-SUMMARY.md
@internal/adapter/driven/github/client.go
@internal/adapter/driven/github/client_test.go
@internal/domain/model/review.go
@internal/domain/model/reviewcomment.go
@internal/domain/model/issuecomment.go
@internal/domain/port/driven/githubclient.go
@internal/adapter/driven/sqlite/prrepo.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement FetchReviews, FetchReviewComments, FetchIssueComments, and update HeadSHA mapping/persistence</name>
  <files>
    internal/adapter/driven/github/client.go
    internal/adapter/driven/github/client_test.go
    internal/adapter/driven/sqlite/prrepo.go
  </files>
  <action>
**Replace the 2 stub methods and add 1 new method in client.go:**

1. **FetchReviews** -- Replace the stub. Use `c.gh.PullRequests.ListReviews(ctx, owner, repo, prNumber, opts)` with pagination (same pattern as FetchPullRequests). Map each `*gh.PullRequestReview` to `model.Review` via a new `mapReview` function:
   - `ID`: `r.GetID()`
   - `PRID`: 0 (caller assigns before storing -- the adapter has no knowledge of the database ID)
   - `ReviewerLogin`: `r.GetUser().GetLogin()`
   - `State`: `model.ReviewState(strings.ToLower(r.GetState()))`
   - `Body`: `r.GetBody()`
   - `CommitID`: `r.GetCommitID()`
   - `SubmittedAt`: `r.GetSubmittedAt().Time`
   - `IsBot`: `false` (bot detection happens in the enrichment service, not the adapter)
   Use `GetXxx()` helpers exclusively to avoid nil pointer panics. Handle pagination via `resp.NextPage == 0` break pattern.

2. **FetchReviewComments** -- Replace the stub. Use `c.gh.PullRequests.ListComments(ctx, owner, repo, prNumber, opts)` with pagination. Map each `*gh.PullRequestComment` to `model.ReviewComment` via a new `mapReviewComment` function:
   - `ID`: `c.GetID()`
   - `ReviewID`: `c.GetPullRequestReviewID()`
   - `PRID`: 0 (caller assigns)
   - `Author`: `c.GetUser().GetLogin()`
   - `Body`: `c.GetBody()`
   - `Path`: `c.GetPath()`
   - `Line`: `c.GetLine()` (int, 0 if absent)
   - `StartLine`: `c.GetStartLine()` (int, 0 for single-line comments)
   - `Side`: `c.GetSide()`
   - `SubjectType`: `c.GetSubjectType()` (returns "line" or "file")
   - `DiffHunk`: `c.GetDiffHunk()`
   - `CommitID`: `c.GetCommitID()`
   - `IsResolved`: `false` (set later from GraphQL data)
   - `IsOutdated`: `false` (set later by enrichment service)
   - `InReplyToID`: The go-github `PullRequestComment` struct has `InReplyTo *int64` with getter `GetInReplyTo() int64`. Map it as follows:
     ```go
     var inReplyTo *int64
     if c.InReplyTo != nil {
         val := c.GetInReplyTo()
         inReplyTo = &val
     }
     ```
     Assign `inReplyTo` to the domain model's `InReplyToID *int64` field.
   - `CreatedAt`: `c.GetCreatedAt().Time`
   - `UpdatedAt`: `c.GetUpdatedAt().Time`

3. **FetchIssueComments** -- NEW method. Use `c.gh.Issues.ListComments(ctx, owner, repo, prNumber, opts)` with pagination. Map each `*gh.IssueComment` to `model.IssueComment`:
   - `ID`: `c.GetID()`
   - `PRID`: 0 (caller assigns)
   - `Author`: `c.GetUser().GetLogin()`
   - `Body`: `c.GetBody()`
   - `IsBot`: `false` (enrichment service handles)
   - `CreatedAt`: `c.GetCreatedAt().Time`
   - `UpdatedAt`: `c.GetUpdatedAt().Time`

4. **mapPullRequest update** -- Add `HeadSHA: pr.GetHead().GetSHA()` to the PullRequest mapping in the existing `mapPullRequest` function.

5. **PRRepo.Upsert update** -- In `internal/adapter/driven/sqlite/prrepo.go`, add `head_sha` to the INSERT and ON CONFLICT UPDATE columns. Add it as a parameter in the ExecContext call. Also update `scanPR` to scan the new `head_sha` column (it's a simple TEXT field, scan directly into `pr.HeadSHA`). Update ALL SELECT queries in prrepo.go to include `head_sha` in the column list.

**Tests in client_test.go:**

Add test cases using httptest server (follow existing pattern in client_test.go):

- `TestFetchReviews`: Mock GitHub API returning 2 reviews (one approved, one changes_requested). Verify domain mapping including CommitID and State.
- `TestFetchReviewComments`: Mock returning 2 comments (one root, one reply with InReplyToID). Verify DiffHunk, Path, Line, StartLine, SubjectType mapping. Verify InReplyToID is nil for root and non-nil for reply.
- `TestFetchIssueComments`: Mock returning 1 issue comment. Verify Author, Body, timestamps.
- `TestFetchPullRequests_HeadSHA`: Verify that the existing FetchPullRequests now populates HeadSHA (add assertion to an existing test or create focused test).
  </action>
  <verify>
`cd /home/esfisher/dev/mygitpanel && go test ./internal/adapter/driven/github/... -v -count=1` passes all tests. `go test ./internal/adapter/driven/sqlite/... -v -count=1` passes (prrepo tests still pass with head_sha). `go build ./...` compiles.
  </verify>
  <done>
FetchReviews returns reviews with CommitID and State from GitHub ListReviews API. FetchReviewComments returns comments with DiffHunk, Path, Line, StartLine, SubjectType, InReplyToID, CommitID from GitHub ListComments API. FetchIssueComments returns general PR comments from GitHub Issues ListComments API. mapPullRequest populates HeadSHA. PRRepo persists and reads HeadSHA. All 3 fetch methods handle pagination. All tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement GraphQL thread resolution client</name>
  <files>
    internal/adapter/driven/github/graphql.go
    internal/adapter/driven/github/graphql_test.go
  </files>
  <action>
**graphql.go** -- Create a minimal GraphQL client for fetching thread resolution status. This is the ONLY data that requires GraphQL (REST API does not expose isResolved).

**Client struct changes (final approach -- no ambiguity):**

Add two fields to the existing `Client` struct:
```go
type Client struct {
    gh             *gh.Client
    username       string
    token          string    // stored for GraphQL Authorization header
    graphqlURL     string    // "https://api.github.com/graphql" in production
}
```

Update constructors with these EXACT final signatures:

1. `NewClient(token, username string) *Client` -- **No signature change** (token is already the first parameter). Store `token` on the struct. Set `graphqlURL` to `"https://api.github.com/graphql"`. The constructor body becomes:
   ```go
   func NewClient(token, username string) *Client {
       cacheTransport := httpcache.NewMemoryCacheTransport()
       rateLimitClient := github_ratelimit.NewClient(cacheTransport, nil)
       client := gh.NewClient(rateLimitClient).WithAuthToken(token)
       return &Client{
           gh:         client,
           username:   username,
           token:      token,
           graphqlURL: "https://api.github.com/graphql",
       }
   }
   ```

2. `NewClientWithHTTPClient(httpClient *http.Client, baseURL, username, token string) (*Client, error)` -- **Adds `token` as 4th parameter**. Existing tests must be updated to pass `"test-token"` (or `""` if GraphQL is not under test). Set `graphqlURL` by replacing the path of baseURL with `/graphql` so httptest servers can intercept it. Example:
   ```go
   func NewClientWithHTTPClient(httpClient *http.Client, baseURL, username, token string) (*Client, error) {
       client := gh.NewClient(httpClient)
       u, err := url.Parse(baseURL)
       if err != nil {
           return nil, fmt.Errorf("parsing base URL: %w", err)
       }
       client.BaseURL = u
       // Derive graphqlURL from baseURL for testability
       graphqlU := *u
       graphqlU.Path = "/graphql"
       return &Client{
           gh:         client,
           username:   username,
           token:      token,
           graphqlURL: graphqlU.String(),
       }, nil
   }
   ```

**Update all existing test callsites** of `NewClientWithHTTPClient` to pass the new `token` parameter as `"test-token"`.

**FetchThreadResolution method on Client:**

3. If `c.token == ""`, return empty map (graceful skip for tests without tokens).
4. Build the GraphQL query (from research):
   ```graphql
   query($owner: String!, $repo: String!, $pr: Int!) {
       repository(owner: $owner, name: $repo) {
           pullRequest(number: $pr) {
               reviewThreads(first: 100) {
                   nodes {
                       isResolved
                       comments(first: 1) {
                           nodes {
                               databaseId
                           }
                       }
                   }
               }
           }
       }
   }
   ```
5. Use `net/http` directly (NOT go-github) to POST to `c.graphqlURL`.
6. Set headers: `Authorization: bearer {token}`, `Content-Type: application/json`.
7. Request body: `{"query": "...", "variables": {"owner": "...", "repo": "...", "pr": N}}`.
8. Parse response into a typed struct:
   ```go
   type graphqlResponse struct {
       Data struct {
           Repository struct {
               PullRequest struct {
                   ReviewThreads struct {
                       Nodes []struct {
                           IsResolved bool `json:"isResolved"`
                           Comments   struct {
                               Nodes []struct {
                                   DatabaseID int64 `json:"databaseId"`
                               } `json:"nodes"`
                           } `json:"comments"`
                       } `json:"nodes"`
                   } `json:"reviewThreads"`
               } `json:"pullRequest"`
           } `json:"repository"`
       } `json:"data"`
       Errors []struct {
           Message string `json:"message"`
       } `json:"errors"`
   }
   ```
9. Build the result map: for each thread node, if it has at least one comment with a databaseId, map `databaseId -> isResolved`.
10. If the response has errors, log a warning and return empty map (do NOT fail -- per research, GraphQL is supplementary).
11. If the HTTP request fails, log a warning and return empty map.
12. Log `hasNextPage` warning if pagination is needed (we don't paginate initially -- `first: 100` covers most PRs).

**graphql_test.go** -- Tests using httptest:

- `TestFetchThreadResolution_Success`: httptest server returns valid GraphQL response with 2 threads (1 resolved, 1 unresolved). Verify map has correct entries.
- `TestFetchThreadResolution_GraphQLErrors`: httptest server returns response with errors array. Verify empty map returned (no error -- graceful degradation).
- `TestFetchThreadResolution_NoToken`: Create client with empty token. Verify empty map returned immediately without making HTTP call.
- `TestFetchThreadResolution_HTTPError`: httptest server returns 500. Verify empty map returned with no panic.

For GraphQL tests, create the client via `NewClientWithHTTPClient(httpClient, server.URL+"/", "testuser", "test-token")` -- the constructor derives `graphqlURL` from the base URL so the httptest server receives the GraphQL POST.

**CRITICAL:** This is a supplementary data source. It MUST NOT cause failures. All error paths return empty map + log warning.
  </action>
  <verify>
`cd /home/esfisher/dev/mygitpanel && go test ./internal/adapter/driven/github/... -v -count=1` passes all tests including new GraphQL tests. `go build ./...` compiles. No new dependencies added (uses only net/http, encoding/json from stdlib).
  </verify>
  <done>
FetchThreadResolution makes a GraphQL query to GitHub, parses the response, and returns a map[int64]bool mapping comment database IDs to resolution status. It degrades gracefully on errors (returns empty map). Client struct stores `token` and `graphqlURL` fields. NewClient (unchanged signature) stores the token internally. NewClientWithHTTPClient gains a `token` parameter (4th arg) and derives graphqlURL from baseURL. 4 test cases cover success, GraphQL errors, no-token, and HTTP errors. All existing tests updated to pass "test-token" to NewClientWithHTTPClient.
  </done>
</task>

</tasks>

<verification>
1. `go test ./internal/adapter/driven/github/... -v` passes all tests (existing + 8+ new)
2. `go test ./internal/adapter/driven/sqlite/... -v` passes all tests (prrepo tests with head_sha)
3. `go build ./...` compiles
4. `go vet ./...` passes
5. No new external dependencies added
6. NewClient signature unchanged (token already first param); NewClientWithHTTPClient gains token as 4th param
7. main.go wiring (Plan 04-04) must pass token to NewClient (already does) -- no change needed in composition root for NewClient
</verification>

<success_criteria>
- FetchReviews, FetchReviewComments, FetchIssueComments are real implementations (not stubs) with pagination
- FetchThreadResolution works via GraphQL with graceful degradation
- mapPullRequest populates HeadSHA
- PRRepo persists and reads HeadSHA
- All adapter methods use GetXxx() helpers to avoid nil pointer panics
- InReplyToID mapped correctly: nil when `c.InReplyTo == nil`, `&val` when non-nil (using `c.GetInReplyTo()`)
- Client struct has token and graphqlURL fields; NewClient stores both; NewClientWithHTTPClient accepts token as 4th param
- All new code has test coverage via httptest mocks
</success_criteria>

<output>
After completion, create `.planning/phases/04-review-intelligence/04-02-SUMMARY.md`
</output>
