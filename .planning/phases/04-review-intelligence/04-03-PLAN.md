---
phase: 04-review-intelligence
plan: 03
type: execute
wave: 3
depends_on: ["04-01", "04-02"]
files_modified:
  - internal/application/reviewservice.go
  - internal/application/reviewservice_test.go
  - internal/application/pollservice.go
  - internal/application/pollservice_test.go
autonomous: true

must_haves:
  truths:
    - "Review comments are grouped into conversation threads by InReplyToID"
    - "Suggestion blocks are extracted from comment bodies as structured proposed changes"
    - "Bot reviews are detected by matching reviewer login against configurable bot usernames"
    - "Nitpick comments are detected by heuristic body-text matching for bot authors"
    - "Outdated reviews are detected by comparing review CommitID against PR HeadSHA"
    - "PR review status is aggregated from latest review per non-bot human reviewer"
    - "Poll service fetches and stores reviews and comments for changed PRs"
  artifacts:
    - path: "internal/application/reviewservice.go"
      provides: "Enrichment service with threading, suggestions, bot detection, outdated detection, status aggregation"
      contains: "ReviewService"
    - path: "internal/application/reviewservice_test.go"
      provides: "Tests for all enrichment logic"
      contains: "TestGroupIntoThreads"
    - path: "internal/application/pollservice.go"
      provides: "Extended poll service that fetches reviews/comments for changed PRs"
      contains: "fetchReviewData"
  key_links:
    - from: "internal/application/reviewservice.go"
      to: "internal/domain/port/driven/reviewstore.go"
      via: "constructor injection of ReviewStore"
      pattern: "driven\\.ReviewStore"
    - from: "internal/application/reviewservice.go"
      to: "internal/domain/port/driven/botconfigstore.go"
      via: "constructor injection of BotConfigStore"
      pattern: "driven\\.BotConfigStore"
    - from: "internal/application/pollservice.go"
      to: "internal/domain/port/driven/githubclient.go"
      via: "FetchReviews, FetchReviewComments, FetchIssueComments calls"
      pattern: "ghClient\\.Fetch"
---

<objective>
Implement the review enrichment service (threading, suggestions, bot detection, outdated detection, review status aggregation) and extend the poll service to fetch and store reviews/comments during the poll cycle.

Purpose: This is the core business logic of Phase 4 -- transforming raw review data into AI-agent-consumable enriched output. The enrichment service is a pure application-layer service with no external dependencies.
Output: ReviewService with enrichment methods, extended PollService with review data fetching.
</objective>

<execution_context>
@/home/esfisher/.claude/get-shit-done/workflows/execute-plan.md
@/home/esfisher/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-review-intelligence/04-RESEARCH.md
@.planning/phases/04-review-intelligence/04-01-SUMMARY.md
@.planning/phases/04-review-intelligence/04-02-SUMMARY.md
@internal/application/pollservice.go
@internal/application/pollservice_test.go
@internal/domain/model/review.go
@internal/domain/model/reviewcomment.go
@internal/domain/model/issuecomment.go
@internal/domain/model/botconfig.go
@internal/domain/model/enums.go
@internal/domain/port/driven/reviewstore.go
@internal/domain/port/driven/botconfigstore.go
@internal/domain/port/driven/githubclient.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ReviewService with enrichment logic</name>
  <files>
    internal/application/reviewservice.go
    internal/application/reviewservice_test.go
  </files>
  <action>
**reviewservice.go** -- New file in `internal/application/`. The ReviewService provides enrichment methods that transform raw stored review data into structured output for the HTTP API. It depends only on port interfaces.

**Struct and constructor:**
```go
type ReviewService struct {
    reviewStore    driven.ReviewStore
    botConfigStore driven.BotConfigStore
}

func NewReviewService(
    reviewStore driven.ReviewStore,
    botConfigStore driven.BotConfigStore,
) *ReviewService
```

**Exported types (used by HTTP handler for response building):**

1. `CommentThread` struct:
   - `RootComment model.ReviewComment`
   - `Replies []model.ReviewComment` (sorted by CreatedAt)
   - `IsResolved bool` (from root comment's IsResolved field)

2. `Suggestion` struct:
   - `CommentID int64`
   - `FilePath string`
   - `StartLine int` (from comment's StartLine; if 0, use Line)
   - `EndLine int` (from comment's Line)
   - `ProposedCode string` (extracted from suggestion block)
   - `OriginalBody string` (full comment body for context)

3. `PRReviewSummary` struct -- the complete enriched view of a PR's review state:
   - `Reviews []model.Review` (all reviews, with IsBot and IsOutdated populated)
   - `Threads []CommentThread` (grouped inline comments)
   - `IssueComments []model.IssueComment` (general PR-level comments, with IsBot populated)
   - `Suggestions []Suggestion` (extracted from review comments)
   - `ReviewStatus model.ReviewState` (aggregated: approved, changes_requested, commented, pending)
   - `HasBotReview bool`
   - `HasCoderabbitReview bool`
   - `AwaitingCoderabbit bool` (no coderabbit review found for current HeadSHA)
   - `ResolvedThreadCount int`
   - `UnresolvedThreadCount int`

**Methods:**

4. `GetPRReviewSummary(ctx context.Context, prID int64, headSHA string) (*PRReviewSummary, error)` -- Main method. Orchestrates:
   a. Load bot usernames via `botConfigStore.GetUsernames(ctx)`
   b. Load reviews via `reviewStore.GetReviewsByPR(ctx, prID)`
   c. Load review comments via `reviewStore.GetReviewCommentsByPR(ctx, prID)`
   d. Load issue comments via `reviewStore.GetIssueCommentsByPR(ctx, prID)`
   e. Mark reviews: `IsBot` (via `isBotUser`), detect outdated (CommitID != headSHA)
   f. Mark issue comments: `IsBot` (via `isBotUser`)
   g. Group review comments into threads (via `groupIntoThreads`)
   h. Extract suggestions from review comments (via `extractSuggestions`)
   i. Compute aggregated review status (via `aggregateReviewStatus`)
   j. Compute bot flags (HasBotReview, HasCoderabbitReview, AwaitingCoderabbit)
   k. Count resolved/unresolved threads
   l. Return assembled PRReviewSummary

**Private helper functions (all pure, no I/O):**

5. `isBotUser(login string, botUsernames []string) bool` -- Case-insensitive match of login against bot usernames list.

6. `isNitpickComment(author, body string, botUsernames []string) bool` -- Returns true if author is a bot AND body contains any nitpick pattern. Patterns (case-insensitive): `"**nitpick"`, `"[nitpick]"`, `"(nitpick)"`, `"nitpick:"`, `"nitpick (non-blocking)"`.

7. `isReviewOutdated(review model.Review, headSHA string) bool` -- Returns true if review.CommitID is non-empty and != headSHA.

8. `groupIntoThreads(comments []model.ReviewComment) []CommentThread` -- Group by InReplyToID:
   - Root comments (InReplyToID == nil) become thread roots
   - Replies (InReplyToID != nil) are attached to their root's thread
   - Sort replies within each thread by CreatedAt
   - Set thread IsResolved from root comment's IsResolved field
   - Handle orphan replies (InReplyToID points to missing root): create a synthetic thread with the orphan as root. This handles edge cases where root was deleted.
   - Sort threads by root comment's CreatedAt (oldest first)

9. `extractSuggestions(comments []model.ReviewComment) []Suggestion` -- For each comment, apply suggestion regex `(?s)\x60{3,}suggestion[^\n]*\n(.*?)\n\x60{3,}` (use compiled `regexp.Regexp` at package level). If match found, create Suggestion with:
   - CommentID, FilePath from comment Path
   - StartLine: if comment.StartLine > 0, use it; else use comment.Line
   - EndLine: comment.Line
   - ProposedCode: captured group 1
   - OriginalBody: comment.Body

10. `aggregateReviewStatus(reviews []model.Review, botUsernames []string) model.ReviewState` -- Compute the PR's overall review status from stored reviews:
    - Filter to non-bot reviewers only
    - For each reviewer, find their LATEST review (by SubmittedAt)
    - If ANY latest review is `changes_requested` -> return `changes_requested`
    - If ALL latest reviews are `approved` (and at least one exists) -> return `approved`
    - If any reviews exist -> return `commented`
    - If no reviews -> return `pending`

11. Private method to compute CodeRabbit flags:
    - `HasCoderabbitReview`: any review where reviewer login case-insensitively matches any bot username that contains "coderabbit"
    - `AwaitingCoderabbit`: no CodeRabbit review exists with CommitID matching headSHA (meaning CodeRabbit hasn't reviewed the latest push)

**reviewservice_test.go** -- Tests using mock implementations of ReviewStore and BotConfigStore:

Define mock structs in the test file (follow existing mock pattern from pollservice_test.go and handler_test.go):

- `TestGroupIntoThreads`: 3 comments (1 root, 2 replies). Verify 1 thread with root + 2 sorted replies.
- `TestGroupIntoThreads_MultipleThreads`: 4 comments (2 roots, 1 reply each). Verify 2 threads.
- `TestGroupIntoThreads_OrphanReply`: 1 reply with InReplyToID pointing to nonexistent root. Verify it becomes its own thread root.
- `TestExtractSuggestions_HasSuggestion`: Comment body with suggestion block. Verify ProposedCode extracted.
- `TestExtractSuggestions_NoSuggestion`: Comment body without suggestion block. Verify no suggestions returned.
- `TestExtractSuggestions_MultipleSuggestions`: Two comments, each with a suggestion. Verify 2 suggestions.
- `TestIsBotUser`: Verify case-insensitive matching.
- `TestIsNitpickComment`: Verify all 5 patterns match for bot author, and non-bot author returns false.
- `TestIsReviewOutdated`: Same commit -> false, different commit -> true, empty commit -> false.
- `TestAggregateReviewStatus_ChangesRequested`: 2 reviewers, one approved, one changes_requested -> changes_requested.
- `TestAggregateReviewStatus_Approved`: 2 reviewers, both approved -> approved.
- `TestAggregateReviewStatus_LatestWins`: Reviewer submits changes_requested then approved -> approved (latest wins).
- `TestAggregateReviewStatus_IgnoreBots`: Bot reviewer's approval does not count.
- `TestGetPRReviewSummary`: Integration test with mocks -- verify the full summary assembly including resolved/unresolved counts, bot flags, review status.

**Important:** The helper functions (groupIntoThreads, extractSuggestions, isBotUser, isNitpickComment, isReviewOutdated, aggregateReviewStatus) should be private but testable. Export them as package-level functions if needed for direct testing, or test them through GetPRReviewSummary. Recommend: make them unexported functions at package level (not methods on ReviewService) and test them directly since they are in the same package.
  </action>
  <verify>
`cd /home/esfisher/dev/mygitpanel && go test ./internal/application/... -v -count=1` passes all tests (existing pollservice + new reviewservice). `go build ./...` compiles.
  </verify>
  <done>
ReviewService provides GetPRReviewSummary that assembles threading, suggestions, bot detection, outdated detection, and review status aggregation. All enrichment logic is pure (no I/O in helpers) and testable. 14+ test cases cover all enrichment paths. CommentThread, Suggestion, and PRReviewSummary types are exported for use by the HTTP handler.
  </done>
</task>

<task type="auto">
  <name>Task 2: Extend PollService to fetch and store reviews/comments</name>
  <files>
    internal/application/pollservice.go
    internal/application/pollservice_test.go
  </files>
  <action>
**Extend PollService to fetch review data during the poll cycle.**

1. **Add new dependencies to PollService struct:**
   - `reviewStore driven.ReviewStore`
   - `botConfigStore driven.BotConfigStore`

2. **Update NewPollService constructor** to accept the 2 new parameters. Add them after the existing `repoStore` parameter:
   ```go
   func NewPollService(
       ghClient driven.GitHubClient,
       prStore driven.PRStore,
       repoStore driven.RepoStore,
       reviewStore driven.ReviewStore,
       botConfigStore driven.BotConfigStore,
       username string,
       teamSlugs []string,
       interval time.Duration,
   ) *PollService
   ```

3. **Add a `fetchReviewData` private method:**
   ```go
   func (s *PollService) fetchReviewData(ctx context.Context, pr model.PullRequest) error
   ```
   This method:
   a. Fetch reviews: `s.ghClient.FetchReviews(ctx, pr.RepoFullName, pr.Number)`
   b. For each review, set `review.PRID = pr.ID` and upsert via `s.reviewStore.UpsertReview`
   c. Fetch review comments: `s.ghClient.FetchReviewComments(ctx, pr.RepoFullName, pr.Number)`
   d. For each comment, set `comment.PRID = pr.ID` and upsert via `s.reviewStore.UpsertReviewComment`
   e. Fetch issue comments: `s.ghClient.FetchIssueComments(ctx, pr.RepoFullName, pr.Number)`
   f. For each issue comment, set `comment.PRID = pr.ID` and upsert via `s.reviewStore.UpsertIssueComment`
   g. Fetch thread resolution: `s.ghClient.FetchThreadResolution(ctx, pr.RepoFullName, pr.Number)`
   h. For each entry in the resolution map, update via `s.reviewStore.UpdateCommentResolution`
   i. Log: `slog.Debug("review data fetched", "repo", pr.RepoFullName, "pr", pr.Number, "reviews", len(reviews), "review_comments", len(comments), "issue_comments", len(issueComments))`
   j. If any fetch step fails, log the error and continue (do NOT abort the entire poll -- partial data is better than none). Specifically: if FetchReviews fails, log and skip. If FetchReviewComments fails, log and skip. Same for issue comments and thread resolution. Each is independent.

4. **Integrate into pollRepo:** After the successful `prStore.Upsert(ctx, pr)` call (line ~199 in current code), AND only when the PR was actually updated (not skipped as unchanged), call `s.fetchReviewData(ctx, pr)`. The PR must have been upserted first so we have a valid `pr.ID` -- but wait, `pr.ID` is set by the database autoincrement on insert. After `prStore.Upsert`, we need the ID. Options:
   - Option A: After upsert, call `prStore.GetByNumber(ctx, pr.RepoFullName, pr.Number)` to get the stored PR with its ID. Then use that ID for review data.
   - Option B: Make Upsert return the ID.

   Use **Option A** since it avoids changing the PRStore interface (which is used by other adapters/tests). The extra SELECT is negligible. After the Upsert succeeds:
   ```go
   storedPR, err := s.prStore.GetByNumber(ctx, pr.RepoFullName, pr.Number)
   if err != nil || storedPR == nil {
       slog.Error("failed to retrieve PR for review fetch", "repo", pr.RepoFullName, "pr", pr.Number, "error", err)
   } else {
       if err := s.fetchReviewData(ctx, *storedPR); err != nil {
           slog.Error("review data fetch failed", "repo", pr.RepoFullName, "pr", pr.Number, "error", err)
       }
   }
   ```

5. **Update existing tests in pollservice_test.go:**
   - Update all `NewPollService` calls to pass the 2 new parameters (mock ReviewStore and BotConfigStore). Create minimal mock implementations:
     ```go
     type mockReviewStore struct{}
     // All methods return nil/empty -- review fetching is tested separately
     ```
     ```go
     type mockBotConfigStore struct{}
     // All methods return nil/empty
     ```
   - The existing mock GitHubClient already returns nil, nil for FetchReviews/FetchReviewComments (stubs). Update it to also implement FetchIssueComments and FetchThreadResolution (return nil/empty).

6. **Add new test: `TestPollRepo_FetchesReviewData`:**
   - Mock GitHubClient returns 1 PR from FetchPullRequests, and returns reviews/comments/issue comments from the review fetch methods
   - Mock ReviewStore records what was upserted
   - Verify that after pollRepo runs, the review store received UpsertReview, UpsertReviewComment, and UpsertIssueComment calls with correct PRID

7. **Add new test: `TestPollRepo_SkipsReviewDataForUnchangedPRs`:**
   - Store a PR that matches the fetched PR (same UpdatedAt, same NeedsReview)
   - Verify that FetchReviews is NOT called for unchanged PRs (review fetch methods should not be invoked)

**Important:** The `fetchReviewData` method must NOT be called for PRs that were skipped as unchanged. This preserves rate limits. Review data is only refreshed when the PR itself has been updated (UpdatedAt changed or NeedsReview changed).
  </action>
  <verify>
`cd /home/esfisher/dev/mygitpanel && go test ./internal/application/... -v -count=1` passes all tests. `go build ./...` compiles.
  </verify>
  <done>
PollService constructor accepts ReviewStore and BotConfigStore. fetchReviewData fetches reviews, review comments, issue comments, and thread resolution for a PR and stores them via ReviewStore. It is called only for PRs that have changed (not skipped as unchanged). Each fetch step is independent -- partial failures are logged but don't abort the poll. All existing tests updated with new constructor parameters. 2 new tests verify review data fetching and skip behavior.
  </done>
</task>

</tasks>

<verification>
1. `go test ./internal/application/... -v` passes all tests (existing + 16+ new)
2. `go build ./...` compiles
3. `go vet ./...` passes
4. ReviewService has no external imports (only domain model and port interfaces)
5. PollService review fetching is gated on PR update detection (rate limit safe)
</verification>

<success_criteria>
- ReviewService.GetPRReviewSummary returns complete enriched view with threads, suggestions, bot flags, review status
- groupIntoThreads correctly handles roots, replies, orphans
- extractSuggestions parses GitHub suggestion markdown blocks
- Bot detection is case-insensitive against configurable usernames
- Outdated detection compares CommitID vs HeadSHA
- Review status aggregation uses latest review per human reviewer
- PollService fetches review data only for changed PRs
- All enrichment helpers are tested with edge cases
</success_criteria>

<output>
After completion, create `.planning/phases/04-review-intelligence/04-03-SUMMARY.md`
</output>
