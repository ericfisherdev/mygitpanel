---
phase: 04-review-intelligence
plan: 04
type: execute
wave: 4
depends_on: ["04-03"]
files_modified:
  - internal/adapter/driving/http/response.go
  - internal/adapter/driving/http/handler.go
  - internal/adapter/driving/http/handler_botconfig.go
  - internal/adapter/driving/http/handler_test.go
  - cmd/mygitpanel/main.go
autonomous: true

must_haves:
  truths:
    - "GET /api/v1/repos/{owner}/{repo}/prs/{number} returns enriched PR detail with review threads, suggestions, issue comments, bot flags, and review status"
    - "Each review comment in the response includes diff_hunk, file_path, line numbers, reviewer name, timestamp, and review action"
    - "Comments are grouped into threads with resolved/unresolved status"
    - "Suggestion blocks are extracted as structured objects with proposed_code, file_path, and line range"
    - "Inline comments (threads) are separated from general PR-level comments (issue_comments) in the response"
    - "Bot flags (has_bot_review, has_coderabbit_review, awaiting_coderabbit) are present on PR detail"
    - "POST/DELETE/GET endpoints for /api/v1/bots allow configuring bot usernames"
    - "Composition root wires ReviewStore, BotConfigStore, ReviewService into handler and poll service"
  artifacts:
    - path: "internal/adapter/driving/http/response.go"
      provides: "Enriched DTO structs for reviews, comments, threads, suggestions"
      contains: "ReviewThreadResponse"
    - path: "internal/adapter/driving/http/handler.go"
      provides: "Updated GetPR handler using ReviewService for enriched responses"
      contains: "reviewSvc"
    - path: "internal/adapter/driving/http/handler_botconfig.go"
      provides: "Bot configuration CRUD endpoints"
      contains: "ListBots"
    - path: "cmd/mygitpanel/main.go"
      provides: "Composition root with all Phase 4 dependencies wired"
      contains: "NewReviewRepo"
  key_links:
    - from: "internal/adapter/driving/http/handler.go"
      to: "internal/application/reviewservice.go"
      via: "ReviewService.GetPRReviewSummary call in GetPR handler"
      pattern: "reviewSvc\\.GetPRReviewSummary"
    - from: "internal/adapter/driving/http/handler_botconfig.go"
      to: "internal/domain/port/driven/botconfigstore.go"
      via: "BotConfigStore injection"
      pattern: "botConfigStore"
    - from: "cmd/mygitpanel/main.go"
      to: "internal/adapter/driven/sqlite/reviewrepo.go"
      via: "NewReviewRepo constructor call"
      pattern: "sqliteadapter\\.NewReviewRepo"
    - from: "cmd/mygitpanel/main.go"
      to: "internal/application/reviewservice.go"
      via: "NewReviewService constructor call"
      pattern: "application\\.NewReviewService"
---

<objective>
Create the HTTP API layer that serves enriched PR review data, add bot configuration endpoints, and wire everything together in the composition root.

Purpose: This is the user-facing output of Phase 4 -- the API responses that an AI agent will consume. Without this plan, the enriched review data stays internal.
Output: Updated GetPR endpoint with enriched response, 3 bot config endpoints, fully wired composition root.
</objective>

<execution_context>
@/home/esfisher/.claude/get-shit-done/workflows/execute-plan.md
@/home/esfisher/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-review-intelligence/04-RESEARCH.md
@.planning/phases/04-review-intelligence/04-01-SUMMARY.md
@.planning/phases/04-review-intelligence/04-02-SUMMARY.md
@.planning/phases/04-review-intelligence/04-03-SUMMARY.md
@internal/adapter/driving/http/handler.go
@internal/adapter/driving/http/handler_test.go
@internal/adapter/driving/http/response.go
@internal/adapter/driving/http/middleware.go
@internal/application/reviewservice.go
@internal/domain/port/driven/reviewstore.go
@internal/domain/port/driven/botconfigstore.go
@cmd/mygitpanel/main.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Expand response DTOs and update GetPR handler with enriched review data</name>
  <files>
    internal/adapter/driving/http/response.go
    internal/adapter/driving/http/handler.go
    internal/adapter/driving/http/handler_test.go
  </files>
  <action>
**response.go -- Add new DTO structs and update PRResponse:**

1. **ReviewResponse** struct -- JSON representation of a single review:
   - `ID int64` `json:"id"`
   - `ReviewerLogin string` `json:"reviewer"`
   - `State string` `json:"state"` (approved, changes_requested, commented, etc.)
   - `Body string` `json:"body"`
   - `CommitID string` `json:"commit_id"`
   - `SubmittedAt string` `json:"submitted_at"` (RFC3339)
   - `IsBot bool` `json:"is_bot"`
   - `IsOutdated bool` `json:"is_outdated"`
   - `IsNitpick bool` `json:"is_nitpick"`

2. **ReviewCommentResponse** struct -- JSON representation of a single review comment:
   - `ID int64` `json:"id"`
   - `Author string` `json:"author"`
   - `Body string` `json:"body"`
   - `FilePath string` `json:"file_path"`
   - `Line int` `json:"line"`
   - `StartLine int` `json:"start_line,omitempty"` (0 omitted for single-line)
   - `Side string` `json:"side"`
   - `SubjectType string` `json:"subject_type"` ("line" or "file")
   - `DiffHunk string` `json:"diff_hunk"`
   - `CommitID string` `json:"commit_id"`
   - `IsOutdated bool` `json:"is_outdated"`
   - `CreatedAt string` `json:"created_at"` (RFC3339)

3. **ReviewThreadResponse** struct -- a grouped conversation thread:
   - `RootComment ReviewCommentResponse` `json:"root_comment"`
   - `Replies []ReviewCommentResponse` `json:"replies"`
   - `IsResolved bool` `json:"is_resolved"`
   - `CommentCount int` `json:"comment_count"` (1 + len(Replies))

4. **SuggestionResponse** struct:
   - `CommentID int64` `json:"comment_id"`
   - `FilePath string` `json:"file_path"`
   - `StartLine int` `json:"start_line"`
   - `EndLine int` `json:"end_line"`
   - `ProposedCode string` `json:"proposed_code"`

5. **IssueCommentResponse** struct -- general PR-level comment:
   - `ID int64` `json:"id"`
   - `Author string` `json:"author"`
   - `Body string` `json:"body"`
   - `IsBot bool` `json:"is_bot"`
   - `CreatedAt string` `json:"created_at"` (RFC3339)

6. **Update PRResponse** -- Replace the placeholder `Reviews []any` and `Comments []any` with structured fields:
   - `Reviews []ReviewResponse` `json:"reviews"` (replaces `[]any`)
   - `Threads []ReviewThreadResponse` `json:"threads"` (NEW)
   - `IssueComments []IssueCommentResponse` `json:"issue_comments"` (NEW -- replaces `Comments []any`)
   - `Suggestions []SuggestionResponse` `json:"suggestions"` (NEW)
   - `ReviewStatus string` `json:"review_status"` (NEW -- aggregated: approved/changes_requested/commented/pending)
   - `HeadSHA string` `json:"head_sha"` (NEW)
   - `HasBotReview bool` `json:"has_bot_review"` (NEW)
   - `HasCoderabbitReview bool` `json:"has_coderabbit_review"` (NEW)
   - `AwaitingCoderabbit bool` `json:"awaiting_coderabbit"` (NEW)
   - `ResolvedThreads int` `json:"resolved_threads"` (NEW)
   - `UnresolvedThreads int` `json:"unresolved_threads"` (NEW)
   Remove the old `Comments []any` field entirely.

7. **Conversion functions** -- Add helper functions to convert from application types to response DTOs:
   - `toReviewResponse(r model.Review, headSHA string, botUsernames []string) ReviewResponse` -- sets IsOutdated from CommitID vs headSHA comparison, IsNitpick from body parsing for bot authors
   - `toReviewCommentResponse(c model.ReviewComment) ReviewCommentResponse`
   - `toReviewThreadResponse(t application.CommentThread) ReviewThreadResponse`
   - `toSuggestionResponse(s application.Suggestion) SuggestionResponse`
   - `toIssueCommentResponse(c model.IssueComment) IssueCommentResponse`

8. **Update toPRResponse** -- The existing `toPRResponse(pr model.PullRequest)` should remain a "basic" conversion that initializes the new fields with empty defaults (empty slices, not nil). The enriched data is populated in the GetPR handler after calling ReviewService.

   Actually, cleaner: change toPRResponse to `toPRResponse(pr model.PullRequest) PRResponse` that sets empty slices for all new fields. Then the GetPR handler populates the enriched fields from the PRReviewSummary. The list endpoints (ListPRs, ListPRsNeedingAttention) continue to return the basic PRResponse without enriched review data -- they should still have empty slices for Reviews, Threads, IssueComments, Suggestions and zero-value for status/flags. This is by design: list endpoints are lightweight, detail endpoint is enriched.

**handler.go -- Update Handler and GetPR:**

9. **Add dependencies to Handler struct:**
   - `reviewSvc *application.ReviewService`
   - `botConfigStore driven.BotConfigStore`

10. **Update NewHandler constructor** to accept the 2 new parameters:
    ```go
    func NewHandler(
        prStore driven.PRStore,
        repoStore driven.RepoStore,
        botConfigStore driven.BotConfigStore,
        reviewSvc *application.ReviewService,
        pollSvc *application.PollService,
        username string,
        logger *slog.Logger,
    ) *Handler
    ```

11. **Update GetPR handler** -- After retrieving the PR from the store, call ReviewService to get enriched data:
    ```go
    summary, err := h.reviewSvc.GetPRReviewSummary(r.Context(), pr.ID, pr.HeadSHA)
    if err != nil {
        h.logger.Error("failed to get review summary", "error", err)
        // Fall through with basic response -- review enrichment failure is not fatal
    }

    resp := toPRResponse(*pr)
    if summary != nil {
        // Populate enriched fields from summary
        resp.Reviews = make([]ReviewResponse, 0, len(summary.Reviews))
        for _, rev := range summary.Reviews {
            resp.Reviews = append(resp.Reviews, toReviewResponse(rev, pr.HeadSHA, /* botUsernames from summary or separate call */))
        }
        // ... populate Threads, IssueComments, Suggestions, status flags
        resp.ReviewStatus = string(summary.ReviewStatus)
        resp.HasBotReview = summary.HasBotReview
        resp.HasCoderabbitReview = summary.HasCoderabbitReview
        resp.AwaitingCoderabbit = summary.AwaitingCoderabbit
        resp.ResolvedThreads = summary.ResolvedThreadCount
        resp.UnresolvedThreads = summary.UnresolvedThreadCount
    }
    ```
    If reviewSvc is nil (e.g., in tests that don't set it up), skip enrichment and return basic response. This maintains backward compatibility for existing handler tests.

12. **Register bot config routes in NewServeMux** -- Add 3 new routes:
    ```go
    mux.HandleFunc("GET /api/v1/bots", h.ListBots)
    mux.HandleFunc("POST /api/v1/bots", h.AddBot)
    mux.HandleFunc("DELETE /api/v1/bots/{username}", h.RemoveBot)
    ```

**handler_test.go -- Update existing tests and add new ones:**

13. Update all `NewHandler` calls with the new parameters. For existing tests that don't need review enrichment, pass nil for reviewSvc and a mock botConfigStore.

14. **New test: TestGetPR_WithEnrichedReviews** -- Mock PRStore returns a PR. Mock ReviewService returns a PRReviewSummary with reviews, threads, suggestions, issue comments, and bot flags. Verify the JSON response includes all enriched fields with correct structure.

15. **New test: TestGetPR_ReviewServiceError** -- Mock ReviewService returns an error. Verify GetPR still returns 200 with basic PR data (enrichment failure is non-fatal).

16. **New test: TestGetPR_CFMT05_InlineVsGeneralSeparation** -- Explicitly verify CFMT-05 requirement: the response separates inline comments (in `"threads"` array as ReviewThreadResponse objects with root_comment, replies, is_resolved) from general PR-level comments (in `"issue_comments"` array as IssueCommentResponse objects with author, body, is_bot). Mock ReviewService to return a PRReviewSummary with both threads (2 inline review comment threads) and issue comments (1 general PR-level comment). Assert:
    - `resp.Threads` has length 2 and each entry has `root_comment.file_path` populated (proving they are inline/code comments)
    - `resp.IssueComments` has length 1 and entries have NO file_path field (proving they are general discussion comments)
    - The two arrays are distinct JSON keys (`"threads"` vs `"issue_comments"`) with no overlap

17. **New test: TestListBots** -- Mock BotConfigStore returns 3 bot configs. Verify JSON array with correct structure.

18. **New test: TestAddBot** -- POST with `{"username": "newbot"}`. Verify 201 response.

19. **New test: TestAddBot_Duplicate** -- POST with existing username. Verify 409 Conflict.

20. **New test: TestRemoveBot** -- DELETE /api/v1/bots/copilot%5Bbot%5D. Verify 204 No Content.

**Important JSON formatting rules (from Phase 3 decisions):**
- Empty arrays for lists, never null: `"reviews": []` not `"reviews": null`
- All timestamps in RFC3339 format
- Consistent snake_case for JSON field names
  </action>
  <verify>
`cd /home/esfisher/dev/mygitpanel && go test ./internal/adapter/driving/http/... -v -count=1` passes all tests (existing updated + 7+ new). `go build ./...` compiles.
  </verify>
  <done>
PRResponse has enriched fields: reviews with outdated/bot/nitpick flags, threaded conversations with resolved status, extracted suggestions, issue comments, aggregated review status, and CodeRabbit flags. GetPR returns enriched data via ReviewService (non-fatal on failure). Inline comments (threads) and general PR-level comments (issue_comments) are separated in the response per CFMT-05. Bot config CRUD endpoints registered. All existing handler tests updated. 7+ new tests verify enriched response structure, inline/general comment separation, and bot config endpoints.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire Phase 4 dependencies in composition root and add bot config handler</name>
  <files>
    internal/adapter/driving/http/handler_botconfig.go
    cmd/mygitpanel/main.go
  </files>
  <action>
**handler_botconfig.go** -- NEW file. Bot configuration CRUD handlers (REPO-04 requirement):

1. **ListBots handler:**
   ```go
   func (h *Handler) ListBots(w http.ResponseWriter, r *http.Request) {
       bots, err := h.botConfigStore.ListAll(r.Context())
       // Error handling follows existing pattern
       resp := make([]BotConfigResponse, 0, len(bots))
       for _, bot := range bots {
           resp = append(resp, toBotConfigResponse(bot))
       }
       writeJSON(w, http.StatusOK, resp)
   }
   ```

2. **AddBot handler:**
   ```go
   func (h *Handler) AddBot(w http.ResponseWriter, r *http.Request) {
       var req AddBotRequest
       // Decode body, validate username not empty
       // Create model.BotConfig with Username and AddedAt
       // Store via botConfigStore.Add
       // Handle unique constraint -> 409 Conflict
       // Return 201 Created with BotConfigResponse
   }
   ```

3. **RemoveBot handler:**
   ```go
   func (h *Handler) RemoveBot(w http.ResponseWriter, r *http.Request) {
       username := r.PathValue("username")
       // URL decode the username (handles "copilot%5Bbot%5D" -> "copilot[bot]")
       // Call botConfigStore.Remove
       // Handle not found -> 404
       // Return 204 No Content
   }
   ```

4. **DTO types** (add to response.go or in handler_botconfig.go):
   - `BotConfigResponse` struct: `Username string` `json:"username"`, `AddedAt string` `json:"added_at"` (RFC3339)
   - `AddBotRequest` struct: `Username string` `json:"username"`
   - `toBotConfigResponse(bot model.BotConfig) BotConfigResponse` conversion function

**cmd/mygitpanel/main.go** -- Wire new dependencies:

5. After the existing adapter instantiation (step 5 in current main.go), add:
   ```go
   // 5b. Wire Phase 4 adapters.
   reviewStore := sqliteadapter.NewReviewRepo(db)
   botConfigStore := sqliteadapter.NewBotConfigRepo(db)
   ```

6. After creating pollSvc (step 7), add ReviewService creation:
   ```go
   // 7b. Create review service.
   reviewSvc := application.NewReviewService(reviewStore, botConfigStore)
   ```

7. **Update PollService constructor** call to pass the 2 new parameters:
   ```go
   pollSvc := application.NewPollService(
       ghClient,
       prStore,
       repoStore,
       reviewStore,      // NEW
       botConfigStore,    // NEW
       cfg.GitHubUsername,
       cfg.GitHubTeams,
       cfg.PollInterval,
   )
   ```

8. **Update NewHandler call** to pass new dependencies:
   ```go
   h := httphandler.NewHandler(
       prStore,
       repoStore,
       botConfigStore,    // NEW
       reviewSvc,         // NEW
       pollSvc,
       cfg.GitHubUsername,
       slog.Default(),
   )
   ```

9. **Note on NewClient wiring:** `NewClient(token, username)` signature is UNCHANGED (Plan 04-02 stores the token internally without changing the signature). The existing `ghClient := github.NewClient(cfg.GitHubToken, cfg.GitHubUsername)` call in main.go needs NO modification.

10. Verify that `go build ./cmd/reviewhub/...` compiles -- this is the integration test for correct wiring. All imports must resolve, all constructors must have matching signatures.

**Verify the complete API surface (10 endpoints):**

| Method | Path | Purpose | New? |
|--------|------|---------|------|
| GET | /api/v1/prs | All tracked PRs (basic) | No |
| GET | /api/v1/prs/attention | PRs needing review (basic) | No |
| GET | /api/v1/repos/{owner}/{repo}/prs/{number} | Single PR (enriched) | Updated |
| GET | /api/v1/repos | All watched repos | No |
| POST | /api/v1/repos | Add repo | No |
| DELETE | /api/v1/repos/{owner}/{repo} | Remove repo | No |
| GET | /api/v1/health | Health check | No |
| GET | /api/v1/bots | List bot usernames | NEW |
| POST | /api/v1/bots | Add bot username | NEW |
| DELETE | /api/v1/bots/{username} | Remove bot username | NEW |
  </action>
  <verify>
`cd /home/esfisher/dev/mygitpanel && go build ./... && go test ./... -count=1` -- full project builds and all tests pass. `go vet ./...` passes. Verify main.go compiles with all new wiring.
  </verify>
  <done>
Bot config handlers (ListBots, AddBot, RemoveBot) are implemented with proper validation and error handling. Composition root wires ReviewRepo, BotConfigRepo, ReviewService into PollService and Handler. NewClient call in main.go is unchanged (token already passed as first arg; Plan 04-02 stores it internally). API has 10 endpoints total (7 existing + 3 new bot config). Full project builds and all tests pass.
  </done>
</task>

</tasks>

<verification>
1. `go build ./...` compiles the entire project including main.go
2. `go test ./... -count=1` passes all tests across all packages
3. `go vet ./...` reports no issues
4. API serves 10 endpoints (7 existing + 3 new)
5. GetPR response includes enriched review data with all required fields
6. GetPR response separates inline comments (threads) from general comments (issue_comments) per CFMT-05
7. Bot config endpoints allow runtime configuration
8. List endpoints return basic PR data (no enrichment overhead)
9. Review enrichment failure in GetPR is non-fatal (returns basic response)
10. main.go NewClient call unchanged -- token storage is internal to Plan 04-02
</verification>

<success_criteria>
- GET PR detail returns reviews with outdated/bot/nitpick flags, threaded conversations, extracted suggestions, issue comments, review status, and CodeRabbit flags
- Inline comments have diff_hunk, file_path, line numbers, reviewer name, timestamp
- Threads show resolved/unresolved status with comment count
- Suggestions have proposed_code, file_path, line range
- Inline comments (threads) are separated from general PR-level comments (issue_comments) in the JSON response
- Bot config CRUD endpoints work (list/add/remove)
- Composition root wires all Phase 4 dependencies
- All existing functionality continues to work
- JSON responses use empty arrays (not null) for all list fields
</success_criteria>

<output>
After completion, create `.planning/phases/04-review-intelligence/04-04-SUMMARY.md`
</output>
