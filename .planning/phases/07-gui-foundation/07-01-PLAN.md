---
phase: 07-gui-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - go.mod
  - go.sum
  - cmd/mygitpanel/main.go
  - Dockerfile
  - .gitignore
  - internal/adapter/driving/web/handler.go
  - internal/adapter/driving/web/routes.go
  - internal/adapter/driving/web/embed.go
  - internal/adapter/driving/web/static/vendor/htmx.min.js
  - internal/adapter/driving/web/static/vendor/alpine.min.js
  - internal/adapter/driving/web/static/vendor/alpine-morph.min.js
  - internal/adapter/driving/web/static/vendor/alpine-persist.min.js
  - internal/adapter/driving/web/static/vendor/htmx-ext-alpine-morph.js
  - internal/adapter/driving/web/static/vendor/gsap.min.js
  - internal/adapter/driving/web/static/css/input.css
  - internal/adapter/driving/web/static/js/animations.js
  - internal/adapter/driving/web/templates/layout.templ
  - internal/adapter/driving/web/templates/pages/dashboard.templ
  - internal/adapter/driving/web/viewmodel.go
autonomous: true

must_haves:
  truths:
    - "Opening http://localhost:8080/ in a browser renders a styled HTML page (not JSON)"
    - "All JS libraries (htmx, Alpine, GSAP) load successfully with no 404s or console errors"
    - "Existing JSON API endpoints at /api/v1/* continue to work unchanged"
    - "Docker build succeeds with templ generate and tailwindcss compilation stages"
    - "go build ./... succeeds locally after templ generate"
  artifacts:
    - path: "internal/adapter/driving/web/handler.go"
      provides: "WebHandler struct with constructor accepting domain port dependencies"
      contains: "NewHandler"
    - path: "internal/adapter/driving/web/routes.go"
      provides: "Route registration for / and /app/* paths plus /static/ file serving"
      contains: "RegisterRoutes"
    - path: "internal/adapter/driving/web/embed.go"
      provides: "go:embed directive for static assets filesystem"
      contains: "go:embed"
    - path: "internal/adapter/driving/web/templates/layout.templ"
      provides: "Base HTML layout with correct script loading order and dark mode wiring"
      contains: "alpine:init"
    - path: "internal/adapter/driving/web/static/css/input.css"
      provides: "Tailwind input CSS with @source directives for templ files"
      contains: "@source"
    - path: "Dockerfile"
      provides: "Multi-stage build with templ generate and tailwindcss steps before go build"
      contains: "templ generate"
  key_links:
    - from: "cmd/mygitpanel/main.go"
      to: "internal/adapter/driving/web/handler.go"
      via: "webhandler.NewHandler() constructor call and RegisterRoutes()"
      pattern: "webhandler\\.NewHandler|webhandler\\.RegisterRoutes"
    - from: "internal/adapter/driving/web/routes.go"
      to: "internal/adapter/driving/web/embed.go"
      via: "http.FileServerFS serving embedded static assets"
      pattern: "StaticFS|FileServerFS"
    - from: "internal/adapter/driving/web/templates/layout.templ"
      to: "/static/vendor/*.js"
      via: "script tags referencing vendored JS libs"
      pattern: "/static/vendor/"
---

<objective>
Scaffold the web GUI driving adapter with build pipeline, vendored JS libraries, Tailwind CSS, templ layout, and a minimal dashboard page that proves the full stack end-to-end.

Purpose: Establish the foundational build pipeline (templ generate -> tailwindcss -> go build) and verify that the dual driving adapter pattern works — HTML served at `/` coexists with JSON at `/api/v1/*`. Every subsequent plan builds on this scaffold.

Output: A browsable dashboard page at `/` with all JS libraries loaded, Tailwind styling active, and dark mode wiring in place. Existing API unchanged.
</objective>

<execution_context>
@/home/esfisher/.claude/get-shit-done/workflows/execute-plan.md
@/home/esfisher/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-gui-foundation/07-RESEARCH.md
@cmd/mygitpanel/main.go
@internal/adapter/driving/http/handler.go
@internal/adapter/driving/http/response.go
@internal/domain/port/driven/prstore.go
@internal/domain/port/driven/repostore.go
@internal/application/reviewservice.go
@internal/application/healthservice.go
@Dockerfile
</context>

<tasks>

<task type="auto">
  <name>Task 1: Vendor JS libraries and create Tailwind input CSS</name>
  <files>
    internal/adapter/driving/web/static/vendor/htmx.min.js
    internal/adapter/driving/web/static/vendor/alpine.min.js
    internal/adapter/driving/web/static/vendor/alpine-morph.min.js
    internal/adapter/driving/web/static/vendor/alpine-persist.min.js
    internal/adapter/driving/web/static/vendor/htmx-ext-alpine-morph.js
    internal/adapter/driving/web/static/vendor/gsap.min.js
    internal/adapter/driving/web/static/css/input.css
    internal/adapter/driving/web/static/js/animations.js
    .gitignore
  </files>
  <action>
    Download vendored JS libraries into `internal/adapter/driving/web/static/vendor/`:

    1. **htmx.min.js** — download from https://unpkg.com/htmx.org@2.0.4/dist/htmx.min.js
    2. **htmx-ext-alpine-morph.js** — download from https://unpkg.com/htmx-ext-alpine-morph@2.0.1/alpine-morph.js
    3. **alpine-morph.min.js** — download from https://unpkg.com/@alpinejs/morph@3.14.9/dist/cdn.min.js
    4. **alpine-persist.min.js** — download from https://unpkg.com/@alpinejs/persist@3.14.9/dist/cdn.min.js
    5. **alpine.min.js** — download from https://unpkg.com/alpinejs@3.14.9/dist/cdn.min.js
    6. **gsap.min.js** — download from https://cdn.jsdelivr.net/npm/gsap@3.13.0/dist/gsap.min.js

    If exact versions are unavailable, use the latest available minor version. The specific version numbers matter less than having the files vendored.

    Create `internal/adapter/driving/web/static/css/input.css`:
    ```css
    @import "tailwindcss";
    @source "../../templates/**/*.templ";
    @source "../../templates/**/*_templ.go";
    @custom-variant dark (&:where(.dark, .dark *));
    ```

    Create `internal/adapter/driving/web/static/js/animations.js` with GSAP animation listeners:
    ```javascript
    // GSAP animations triggered by HTMX swap events (GUI-06).
    document.addEventListener('htmx:afterSwap', function(event) {
        var target = event.detail.target;
        if (target.id === 'pr-detail') {
            gsap.from('#pr-detail > *', {
                opacity: 0, y: 20, duration: 0.3, stagger: 0.05, ease: 'power2.out'
            });
        }
        if (target.id === 'pr-list') {
            gsap.from('#pr-list > *', {
                opacity: 0, x: -10, duration: 0.2, stagger: 0.03, ease: 'power1.out'
            });
        }
    });
    ```

    Add `internal/adapter/driving/web/static/css/output.css` to `.gitignore` (generated file).

    **Do NOT use Node.js or npm.** All downloads via curl.
  </action>
  <verify>
    - All 6 JS files exist in `internal/adapter/driving/web/static/vendor/` and are non-empty
    - `input.css` exists with `@import "tailwindcss"` and `@source` directives
    - `animations.js` exists with `htmx:afterSwap` listener
    - `output.css` is listed in `.gitignore`
  </verify>
  <done>
    All frontend vendor libraries are committed and the Tailwind input CSS is configured to scan templ files. Animation JS file is ready.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create web adapter scaffold with templ layout, handler, routes, embed, and Dockerfile update</name>
  <files>
    go.mod
    go.sum
    internal/adapter/driving/web/handler.go
    internal/adapter/driving/web/routes.go
    internal/adapter/driving/web/embed.go
    internal/adapter/driving/web/viewmodel.go
    internal/adapter/driving/web/templates/layout.templ
    internal/adapter/driving/web/templates/pages/dashboard.templ
    cmd/mygitpanel/main.go
    Dockerfile
  </files>
  <action>
    **Step 1: Add templ dependency.**

    ```bash
    cd /home/esfisher/dev/mygitpanel
    go get github.com/a-h/templ
    go get -tool github.com/a-h/templ/cmd/templ@latest
    ```

    **Step 2: Create `internal/adapter/driving/web/embed.go`:**

    ```go
    package web

    import "embed"

    //go:embed static/*
    var StaticFS embed.FS
    ```

    Note: The `go:embed` directive embeds the entire `static/` tree including vendor JS, CSS, and animation JS. At build time, `output.css` must exist (generated by Tailwind CLI before `go build`).

    **Step 3: Create `internal/adapter/driving/web/viewmodel.go`:**

    Define a minimal `PageData` struct for the layout. More view models will be added in Plan 02.

    ```go
    package web

    // PageData holds data passed to the base layout template.
    type PageData struct {
        Title string
    }
    ```

    **Step 4: Create `internal/adapter/driving/web/handler.go`:**

    ```go
    package web

    import (
        "log/slog"
        "net/http"

        "github.com/ericfisherdev/mygitpanel/internal/application"
        "github.com/ericfisherdev/mygitpanel/internal/domain/port/driven"
    )

    // Handler is the web GUI driving adapter that serves HTML via templ components.
    type Handler struct {
        prStore   driven.PRStore
        repoStore driven.RepoStore
        reviewSvc *application.ReviewService
        healthSvc *application.HealthService
        pollSvc   *application.PollService
        username  string
        logger    *slog.Logger
    }

    // NewHandler creates a Handler with all required dependencies.
    func NewHandler(
        prStore driven.PRStore,
        repoStore driven.RepoStore,
        reviewSvc *application.ReviewService,
        healthSvc *application.HealthService,
        pollSvc *application.PollService,
        username string,
        logger *slog.Logger,
    ) *Handler {
        return &Handler{
            prStore:   prStore,
            repoStore: repoStore,
            reviewSvc: reviewSvc,
            healthSvc: healthSvc,
            pollSvc:   pollSvc,
            username:  username,
            logger:    logger,
        }
    }

    // Dashboard renders the main dashboard page with the full HTML layout.
    func (h *Handler) Dashboard(w http.ResponseWriter, r *http.Request) {
        component := pages.Dashboard()
        layout := templates.Layout("ReviewHub", component)
        if err := layout.Render(r.Context(), w); err != nil {
            h.logger.Error("failed to render dashboard", "error", err)
            http.Error(w, "internal server error", http.StatusInternalServerError)
        }
    }
    ```

    The handler imports the generated templ packages. The import paths will be:
    - `github.com/ericfisherdev/mygitpanel/internal/adapter/driving/web/templates` for `Layout`
    - `github.com/ericfisherdev/mygitpanel/internal/adapter/driving/web/templates/pages` for `Dashboard`

    Adjust imports as needed after templ generates the Go files.

    **Step 5: Create `internal/adapter/driving/web/routes.go`:**

    ```go
    package web

    import (
        "io/fs"
        "net/http"
    )

    // RegisterRoutes registers all web GUI routes on the provided mux.
    // Web routes serve HTML at / and /app/* paths.
    // Static assets are served from the embedded filesystem at /static/*.
    func RegisterRoutes(mux *http.ServeMux, h *Handler) {
        // Static assets (embedded via go:embed).
        staticFS, _ := fs.Sub(StaticFS, "static")
        mux.Handle("GET /static/", http.StripPrefix("/static/", http.FileServerFS(staticFS)))

        // Page routes.
        mux.HandleFunc("GET /{$}", h.Dashboard)
    }
    ```

    The `/{$}` pattern matches only the root path exactly (Go 1.22+ routing).

    **Step 6: Create `internal/adapter/driving/web/templates/layout.templ`:**

    ```templ
    package templates

    import "github.com/a-h/templ"

    templ Layout(title string, contents templ.Component) {
        <!DOCTYPE html>
        <html lang="en" x-data x-bind:class="$store.theme.dark ? 'dark' : ''">
        <head>
            <meta charset="UTF-8"/>
            <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
            <title>{ title }</title>
            <link rel="stylesheet" href="/static/css/output.css"/>
        </head>
        <body class="bg-gray-50 dark:bg-gray-900 text-gray-900 dark:text-gray-100 min-h-screen" hx-ext="alpine-morph">
            @contents
            <!-- Script loading order is CRITICAL: htmx -> htmx-ext-alpine-morph -> alpine plugins -> alpine core -->
            <script src="/static/vendor/htmx.min.js"></script>
            <script src="/static/vendor/htmx-ext-alpine-morph.js"></script>
            <script src="/static/vendor/alpine-morph.min.js" defer></script>
            <script src="/static/vendor/alpine-persist.min.js" defer></script>
            <script src="/static/vendor/alpine.min.js" defer></script>
            <script src="/static/vendor/gsap.min.js"></script>
            <script src="/static/js/animations.js" defer></script>
            <script>
                document.addEventListener('alpine:init', function() {
                    Alpine.store('theme', {
                        dark: Alpine.$persist(false).as('darkMode')
                    });
                });
            </script>
        </body>
        </html>
    }
    ```

    **Step 7: Create `internal/adapter/driving/web/templates/pages/dashboard.templ`:**

    A minimal placeholder dashboard that proves the full pipeline works:

    ```templ
    package pages

    templ Dashboard() {
        <div class="flex h-screen">
            <!-- Sidebar placeholder -->
            <aside id="sidebar" class="w-64 bg-white dark:bg-gray-800 border-r border-gray-200 dark:border-gray-700 p-4">
                <h1 class="text-xl font-bold text-indigo-600 dark:text-indigo-400">ReviewHub</h1>
                <p class="text-sm text-gray-500 dark:text-gray-400 mt-2">PR Dashboard</p>
                <div id="pr-list" class="mt-4">
                    <p class="text-gray-400 dark:text-gray-500 text-sm">PR feed loading in Plan 02...</p>
                </div>
            </aside>
            <!-- Main content area -->
            <main class="flex-1 p-6 overflow-y-auto">
                <div id="pr-detail" class="flex items-center justify-center h-full">
                    <p class="text-gray-400 dark:text-gray-500 text-lg">Select a PR to view details</p>
                </div>
            </main>
        </div>
    }
    ```

    **Step 8: Wire web handler into `cmd/mygitpanel/main.go`:**

    Add the web handler import and registration AFTER the existing HTTP handler setup. The key change: create the mux FIRST, then register both handlers on it, then wrap with middleware.

    Replace the current handler/mux creation block (lines ~94-95) with:
    ```go
    // 7.5. Create HTTP handler and register API routes.
    apiHandler := httphandler.NewHandler(prStore, repoStore, botConfigStore, reviewSvc, healthSvc, pollSvc, cfg.GitHubUsername, slog.Default())
    mux := http.NewServeMux()
    httphandler.RegisterAPIRoutes(mux, apiHandler)

    // 7.6. Create web handler and register GUI routes.
    webHandler := web.NewHandler(prStore, repoStore, reviewSvc, healthSvc, pollSvc, cfg.GitHubUsername, slog.Default())
    web.RegisterRoutes(mux, webHandler)

    // Apply middleware.
    handler := httphandler.ApplyMiddleware(mux, slog.Default())
    ```

    This requires a small refactor in `internal/adapter/driving/http/handler.go`:
    - Extract route registration from `NewServeMux()` into a `RegisterAPIRoutes(mux, h)` function
    - Extract middleware wrapping into an `ApplyMiddleware(handler, logger)` function
    - Keep `NewServeMux()` as a convenience that calls both (for backward compatibility in tests)

    Import alias: `web "github.com/ericfisherdev/mygitpanel/internal/adapter/driving/web"`

    **Step 9: Update Dockerfile:**

    Modify the build stage to install templ CLI and Tailwind standalone CLI, then run the generation steps before `go build`:

    ```dockerfile
    FROM golang:1.25-alpine AS build

    # Install templ CLI
    RUN go install github.com/a-h/templ/cmd/templ@latest

    # Download Tailwind standalone CLI v4
    RUN wget -O /usr/local/bin/tailwindcss \
        https://github.com/tailwindlabs/tailwindcss/releases/latest/download/tailwindcss-linux-x64-musl \
        && chmod +x /usr/local/bin/tailwindcss

    WORKDIR /src
    COPY go.mod go.sum ./
    RUN go mod download && go mod verify
    COPY . .

    # Generate templ Go files from .templ sources
    RUN templ generate

    # Build Tailwind CSS (must run after templ generate so _templ.go files exist for scanning)
    RUN tailwindcss -i internal/adapter/driving/web/static/css/input.css \
        -o internal/adapter/driving/web/static/css/output.css --minify

    # Build Go binaries (static assets embedded via go:embed including output.css)
    RUN CGO_ENABLED=0 GOOS=linux go build -trimpath -ldflags="-s -w" -o /bin/mygitpanel ./cmd/mygitpanel
    RUN CGO_ENABLED=0 GOOS=linux go build -trimpath -ldflags="-s -w" -o /bin/healthcheck ./cmd/healthcheck
    RUN mkdir -p /data /tmp
    ```

    Keep the runtime stage unchanged (FROM scratch).

    **Step 10: Run `templ generate` locally and verify `go build ./...` succeeds.**

    Install templ CLI locally if not present: `go install github.com/a-h/templ/cmd/templ@latest`
    Run: `templ generate` from project root.
    Generate a placeholder output.css: `touch internal/adapter/driving/web/static/css/output.css`
    Run: `go build ./...`
    Run: `go test ./...` (all existing tests must still pass)
  </action>
  <verify>
    - `go build ./...` succeeds (after `templ generate` and creating placeholder output.css)
    - `go test ./...` passes with all existing tests green
    - `internal/adapter/driving/web/templates/layout_templ.go` exists (generated by templ)
    - `internal/adapter/driving/web/templates/pages/dashboard_templ.go` exists (generated by templ)
    - Starting the server and visiting `http://localhost:8080/` returns styled HTML
    - Visiting `http://localhost:8080/api/v1/health` still returns JSON health response
    - Browser dev tools Network tab shows all `/static/vendor/*.js` loading with 200 status
    - Browser console has no errors related to Alpine, HTMX, or GSAP initialization
  </verify>
  <done>
    The web adapter scaffold is complete: layout renders, all JS libraries load, Tailwind styling works, existing API is untouched, and the Dockerfile builds the full pipeline.
  </done>
</task>

</tasks>

<verification>
1. `go build ./...` succeeds after `templ generate`
2. `go test ./...` — all existing tests pass
3. `curl http://localhost:8080/` returns HTML containing "ReviewHub"
4. `curl http://localhost:8080/api/v1/health` returns JSON `{"status":"ok"}`
5. Browser loads all 6 vendor JS files without 404
6. Browser console shows no JS errors
7. Dockerfile builds successfully with `docker build .`
</verification>

<success_criteria>
- Web GUI scaffold serves HTML at root path
- JSON API routes continue working at /api/v1/*
- All frontend JS libraries are vendored and embedded
- Tailwind CSS pipeline configured with templ @source scanning
- Dockerfile builds with templ generate -> tailwindcss -> go build pipeline
- Dark mode Alpine store initialized (toggle comes in Plan 03)
</success_criteria>

<output>
After completion, create `.planning/phases/07-gui-foundation/07-01-SUMMARY.md`
</output>
