---
phase: 03-core-api
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - internal/adapter/driving/http/response.go
  - internal/adapter/driving/http/middleware.go
  - internal/adapter/driving/http/handler.go
  - internal/adapter/driving/http/handler_test.go
  - cmd/reviewhub/main.go
autonomous: true

must_haves:
  truths:
    - "GET /api/v1/prs returns all tracked PRs with status, title, author, branch, base_branch, url, labels"
    - "GET /api/v1/repos/{owner}/{repo}/prs/{number} returns a single PR with full metadata"
    - "GET /api/v1/prs/attention returns only PRs needing review"
    - "POST /api/v1/repos adds a repository and triggers async refresh"
    - "DELETE /api/v1/repos/{owner}/{repo} removes a repository"
    - "GET /api/v1/repos lists all watched repositories"
    - "GET /api/v1/health returns ok status"
    - "HTTP server starts on configured address and shuts down gracefully"
  artifacts:
    - path: "internal/adapter/driving/http/response.go"
      provides: "JSON helpers (writeJSON, writeError) and all DTO structs"
      exports: ["writeJSON", "writeError", "PRResponse", "RepoResponse", "HealthResponse"]
    - path: "internal/adapter/driving/http/middleware.go"
      provides: "Logging and recovery middleware"
      exports: ["loggingMiddleware", "recoveryMiddleware"]
    - path: "internal/adapter/driving/http/handler.go"
      provides: "Handler struct with all 7 endpoint methods and route registration"
      exports: ["Handler", "NewHandler"]
    - path: "internal/adapter/driving/http/handler_test.go"
      provides: "Table-driven httptest tests for all endpoints"
      min_lines: 150
    - path: "cmd/reviewhub/main.go"
      provides: "HTTP server creation, wiring, and graceful shutdown"
      contains: "http.Server"
  key_links:
    - from: "internal/adapter/driving/http/handler.go"
      to: "internal/domain/port/driven/prstore.go"
      via: "prStore field on Handler struct"
      pattern: "prStore.*driven\\.PRStore"
    - from: "internal/adapter/driving/http/handler.go"
      to: "internal/domain/port/driven/repostore.go"
      via: "repoStore field on Handler struct"
      pattern: "repoStore.*driven\\.RepoStore"
    - from: "internal/adapter/driving/http/handler.go"
      to: "internal/application/pollservice.go"
      via: "pollSvc field for async refresh on repo add"
      pattern: "pollSvc.*PollService"
    - from: "cmd/reviewhub/main.go"
      to: "internal/adapter/driving/http/handler.go"
      via: "NewHandler + RegisterRoutes in composition root"
      pattern: "httphandler\\.NewHandler"
---

<objective>
Build the complete HTTP API layer: JSON response helpers, logging/recovery middleware, all 7 REST endpoints (3 PR + 3 repo + 1 health), table-driven tests, and wire the HTTP server into the composition root with graceful shutdown.

Purpose: This is the core deliverable of Phase 3 -- making PR data and repository configuration accessible via structured HTTP endpoints that a CLI agent can consume. All 8 Phase 3 requirements (API-01 through API-04, REPO-01 through REPO-03, STAT-01, STAT-07) are satisfied by these endpoints.

Output: A fully functional HTTP API listening on the configured address, all endpoints tested via httptest, and graceful shutdown integrated with existing signal handling.
</objective>

<execution_context>
@C:\Users\EFisher\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\EFisher\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-core-api/03-RESEARCH.md
@.planning/phases/03-core-api/03-01-SUMMARY.md

@internal/domain/model/pullrequest.go
@internal/domain/model/repository.go
@internal/domain/model/enums.go
@internal/domain/port/driven/prstore.go
@internal/domain/port/driven/repostore.go
@internal/application/pollservice.go
@cmd/reviewhub/main.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create HTTP response helpers, DTOs, middleware, and handler with all endpoints</name>
  <files>
    internal/adapter/driving/http/response.go
    internal/adapter/driving/http/middleware.go
    internal/adapter/driving/http/handler.go
  </files>
  <action>
    **Create `internal/adapter/driving/http/response.go`:**

    Package `httphandler` (use this name to avoid conflict with stdlib `http`).

    1. `writeJSON(w http.ResponseWriter, status int, v any)` -- Set Content-Type to `application/json; charset=utf-8`, json.Marshal to bytes first (NOT json.NewEncoder -- need to check marshal errors before writing status), then WriteHeader, then Write. On marshal error, write 500 with hardcoded JSON error string.

    2. `writeError(w http.ResponseWriter, status int, message string)` -- calls writeJSON with `errorResponse{Error: message}`.

    3. Response DTO structs (all with json tags):
       - `errorResponse` with `Error string` field
       - `PRResponse` with fields: Number (int), Repository (string), Title (string), Author (string), Status (string), IsDraft (bool, `json:"is_draft"`), NeedsReview (bool, `json:"needs_review"`), URL (string, `json:"url"`), Branch (string), BaseBranch (string, `json:"base_branch"`), Labels ([]string), Reviews ([]any, `json:"reviews"`), Comments ([]any, `json:"comments"`), OpenedAt (string, `json:"opened_at"`), UpdatedAt (string, `json:"updated_at"`)
       - `RepoResponse` with fields: FullName (string, `json:"full_name"`), Owner (string), Name (string), AddedAt (string, `json:"added_at"`)
       - `HealthResponse` with fields: Status (string), Time (string)
       - `AddRepoRequest` with field: FullName (string, `json:"full_name"`)

    4. Converter functions:
       - `toPRResponse(pr model.PullRequest) PRResponse` -- maps all fields. Use `pr.OpenedAt.UTC().Format(time.RFC3339)` for timestamps. For Labels: if nil, initialize to `[]string{}` to avoid JSON null. For Reviews and Comments: always `[]any{}` (empty arrays, Phase 4 populates). Repository field = pr.RepoFullName.
       - `toRepoResponse(repo model.Repository) RepoResponse` -- maps all fields, format AddedAt as RFC3339.

    **Create `internal/adapter/driving/http/middleware.go`:**

    Package `httphandler`.

    1. `statusWriter` struct: embeds `http.ResponseWriter`, has `status int` field. Override `WriteHeader(status int)` to capture status code and delegate to embedded writer.

    2. `loggingMiddleware(logger *slog.Logger, next http.Handler) http.Handler`: wraps handler, records start time, creates statusWriter, calls next.ServeHTTP, logs with slog.Info: method, path, status, duration (rounded to microsecond).

    3. `recoveryMiddleware(logger *slog.Logger, next http.Handler) http.Handler`: defer/recover pattern. On panic, log slog.Error with panic value and path, call writeError with 500 "internal server error".

    **Create `internal/adapter/driving/http/handler.go`:**

    Package `httphandler`.

    1. `Handler` struct with fields:
       - `prStore driven.PRStore`
       - `repoStore driven.RepoStore`
       - `pollSvc *application.PollService`
       - `username string`
       - `logger *slog.Logger`

    2. `NewHandler(prStore driven.PRStore, repoStore driven.RepoStore, pollSvc *application.PollService, username string, logger *slog.Logger) *Handler`

    3. `NewServeMux(h *Handler, logger *slog.Logger) http.Handler` -- creates `http.NewServeMux()`, registers all routes using Go 1.22+ method+path syntax, wraps mux with recoveryMiddleware then loggingMiddleware (recovery innermost so panics are caught before logging), returns the wrapped handler. Routes:
       - `"GET /api/v1/prs"` -> h.ListPRs
       - `"GET /api/v1/prs/attention"` -> h.ListPRsNeedingAttention
       - `"GET /api/v1/repos/{owner}/{repo}/prs/{number}"` -> h.GetPR
       - `"GET /api/v1/repos"` -> h.ListRepos
       - `"POST /api/v1/repos"` -> h.AddRepo
       - `"DELETE /api/v1/repos/{owner}/{repo}"` -> h.RemoveRepo
       - `"GET /api/v1/health"` -> h.Health

    4. Handler methods (each is a thin adapter: parse request -> call store -> format response):

       **ListPRs** (API-01, STAT-01, STAT-07): Call `h.prStore.ListAll(r.Context())`. Convert each PR to PRResponse. Return 200 with array. On error: log, return 500.

       **GetPR** (API-02): Extract owner, repo, number from path values. Validate number with strconv.Atoi (400 on error). Build repoFullName as owner+"/"+repo. Call `h.prStore.GetByNumber`. If nil: 404 "pull request not found". Else: 200 with single PRResponse.

       **ListPRsNeedingAttention** (API-03): Call `h.prStore.ListNeedingReview(r.Context())`. Convert to PRResponse array. Return 200. On error: log, return 500.

       **ListRepos** (REPO-03): Call `h.repoStore.ListAll(r.Context())`. Convert to RepoResponse array. Return 200. On error: log, return 500.

       **AddRepo** (REPO-01): Decode JSON body into AddRepoRequest. Validate full_name with `isValidRepoName` (must match `owner/repo` format: non-empty parts, no extra slashes, alphanumeric/hyphens/dots/underscores only). Split into owner/name. Create model.Repository. Call `h.repoStore.Add`. On duplicate (error string contains "UNIQUE constraint"): 409 "repository already exists". On success: 201 with RepoResponse. Fire-and-forget goroutine: `go h.pollSvc.RefreshRepo(context.Background(), req.FullName)` -- use background context since the HTTP request context will be cancelled after response. Log any refresh error inside the goroutine.

       **RemoveRepo** (REPO-02): Extract owner, repo from path. Build fullName. Call `h.repoStore.Remove`. On "not found" in error: 404. Else on error: 500. On success: 204 No Content (no body).

       **Health** (API-04): Return 200 with HealthResponse{Status: "ok", Time: time.Now().UTC().Format(time.RFC3339)}.

    5. `isValidRepoName(name string) bool` -- validate owner/repo format: split by "/", must have exactly 2 non-empty parts, each part must match `[a-zA-Z0-9._-]+` pattern. Use `strings.SplitN(name, "/", 3)` and check len == 2 (rejects extra slashes). Use a simple loop or regexp for character validation.
  </action>
  <verify>
    `go build ./...` compiles without errors (handler, response, middleware all parse).
    `go vet ./internal/adapter/driving/http/...` passes.
  </verify>
  <done>
    - response.go has writeJSON, writeError, all DTOs, converter functions
    - middleware.go has logging and recovery middleware
    - handler.go has Handler struct, NewHandler, NewServeMux, all 7 endpoint methods, isValidRepoName
    - Project compiles cleanly
  </done>
</task>

<task type="auto">
  <name>Task 2: Add handler tests and wire HTTP server into composition root</name>
  <files>
    internal/adapter/driving/http/handler_test.go
    cmd/reviewhub/main.go
  </files>
  <action>
    **Create `internal/adapter/driving/http/handler_test.go`:**

    Package `httphandler_test` (external test package for black-box testing).

    1. Create mock structs that implement the port interfaces:
       - `mockPRStore` with fields: `prs []model.PullRequest`, `pr *model.PullRequest`, `err error`. Implement all PRStore methods: ListAll returns prs/err, GetByNumber returns pr/err, ListNeedingReview returns prs/err, others return nil/nil (not tested here).
       - `mockRepoStore` with fields: `repos []model.Repository`, `err error`, `addErr error`, `removeErr error`, `addedRepo model.Repository`. Implement all RepoStore methods: ListAll returns repos/err, Add captures repo to addedRepo and returns addErr, Remove returns removeErr, GetByFullName returns nil/nil.
       - `mockPollService` -- the PollService is a concrete struct, not an interface. For the AddRepo fire-and-forget goroutine, the handler calls `pollSvc.RefreshRepo`. For tests, pass `nil` as pollSvc and guard the goroutine in handler.go: only fire refresh if `h.pollSvc != nil`. This allows tests to pass nil without panicking.

    2. Table-driven tests using httptest.NewRequest + httptest.NewRecorder pattern (matching existing project conventions with testify):

       **TestListPRs:**
       - Case "empty list": mockPRStore{prs: nil} -> 200, empty JSON array `[]`
       - Case "two PRs": mockPRStore with 2 PRs (open + merged, with labels) -> 200, array of 2, verify first PR has correct fields
       - Case "store error": mockPRStore{err: errors.New("db fail")} -> 500, error response

       **TestGetPR:**
       - Case "found": mockPRStore{pr: &testPR} -> 200, correct fields
       - Case "not found": mockPRStore{pr: nil} -> 404, error message "pull request not found"
       - Case "invalid number": request to `/api/v1/repos/owner/repo/prs/abc` -> 400, error message "invalid PR number"

       **TestListPRsNeedingAttention:**
       - Case "returns only needing review": mockPRStore with 1 PR where NeedsReview=true -> 200, array of 1

       **TestListRepos:**
       - Case "empty": mockRepoStore{repos: nil} -> 200, empty array
       - Case "two repos": 2 repos -> 200, array of 2

       **TestAddRepo:**
       - Case "valid": POST with `{"full_name": "owner/repo"}` -> 201, RepoResponse with correct fields
       - Case "invalid format": POST with `{"full_name": "invalid"}` -> 400
       - Case "duplicate": mockRepoStore{addErr: with UNIQUE constraint message} -> 409

       **TestRemoveRepo:**
       - Case "success": DELETE /api/v1/repos/owner/repo -> 204, empty body
       - Case "not found": removeErr with "not found" -> 404

       **TestHealth:**
       - Case "returns ok": GET /api/v1/health -> 200, status "ok", time field present

       For tests that use path parameters ({owner}, {repo}, {number}), you MUST register the handler on a real ServeMux and use that to serve the request, because `r.PathValue()` only works when the request was matched by a ServeMux pattern. Create a helper:
       ```go
       func setupMux(h *httphandler.Handler) http.Handler {
           return httphandler.NewServeMux(h, slog.Default())
       }
       ```
       Then use `mux.ServeHTTP(rec, req)` instead of calling handler methods directly.

       For tests that do NOT use path params (ListPRs, ListPRsNeedingAttention, ListRepos, Health), you can call the handler method directly OR go through the mux. Going through the mux is simpler and consistent.

    3. Ensure nil slices in responses: verify that JSON responses contain `"labels": []` not `"labels": null`, and `"reviews": []` not `"reviews": null`.

    **Update `cmd/reviewhub/main.go`:**

    1. Add import for `httphandler "github.com/efisher/reviewhub/internal/adapter/driving/http"` and `"net/http"`.

    2. After step 7 (poll service creation and start), add step 7.5: Create HTTP handler and server:
       ```go
       // 7.5. Create HTTP handler and server.
       h := httphandler.NewHandler(prStore, repoStore, pollSvc, cfg.GitHubUsername, slog.Default())
       mux := httphandler.NewServeMux(h, slog.Default())

       srv := &http.Server{
           Addr:              cfg.ListenAddr,
           Handler:           mux,
           ReadHeaderTimeout: 5 * time.Second,
           ReadTimeout:       10 * time.Second,
           WriteTimeout:      30 * time.Second,
           IdleTimeout:       120 * time.Second,
       }

       go func() {
           slog.Info("http server starting", "addr", cfg.ListenAddr)
           if err := srv.ListenAndServe(); err != nil && err != http.ErrServerClosed {
               slog.Error("http server error", "error", err)
           }
       }()
       ```

    3. Replace the placeholder `_ = shutdownCtx` line (step 10) with actual server shutdown:
       ```go
       if err := srv.Shutdown(shutdownCtx); err != nil {
           slog.Error("http server shutdown error", "error", err)
       }
       ```
       Remove the comment "Future phases will use shutdownCtx to drain the HTTP server."

    4. Update log messages: step 8 "reviewhub started" already logs listen_addr which is correct.
  </action>
  <verify>
    Run: `go test ./internal/adapter/driving/http/... -v` -- all handler tests pass.
    Run: `go test ./internal/... -v` -- all project tests pass.
    Run: `go build ./cmd/reviewhub/` -- binary compiles.
    Run: `go vet ./...` -- no vet issues.
  </verify>
  <done>
    - All 7 endpoints have table-driven tests passing
    - Empty lists return `[]` not `null` in JSON
    - HTTP server starts on configured address with production timeouts
    - Graceful shutdown drains HTTP connections within 10s timeout
    - Binary compiles and all tests pass
  </done>
</task>

</tasks>

<verification>
1. `go build ./cmd/reviewhub/` -- binary compiles
2. `go test ./internal/... -v` -- all tests pass (existing + new handler tests + new ListNeedingReview test from Plan 01)
3. `go vet ./...` -- no issues
4. Verify endpoint contracts via test output:
   - GET /api/v1/prs -> 200, array of PRResponse with all STAT-01/STAT-07 fields
   - GET /api/v1/repos/{owner}/{repo}/prs/{number} -> 200 (found) or 404 (not found) or 400 (invalid number)
   - GET /api/v1/prs/attention -> 200, filtered array
   - GET /api/v1/repos -> 200, array of RepoResponse
   - POST /api/v1/repos -> 201 (created) or 400 (invalid) or 409 (duplicate)
   - DELETE /api/v1/repos/{owner}/{repo} -> 204 (success) or 404 (not found)
   - GET /api/v1/health -> 200, {status: "ok", time: "..."}
</verification>

<success_criteria>
- All 7 HTTP endpoints implemented and tested
- JSON responses use correct Content-Type, proper status codes, empty arrays (not null)
- PRResponse includes all fields from STAT-01 (status) and STAT-07 (title, author, branch, base_branch, url, labels)
- Reviews/Comments fields present as empty arrays (Phase 4 populates)
- Logging middleware logs method, path, status, duration for every request
- Recovery middleware catches panics and returns 500
- AddRepo triggers async poll refresh (fire-and-forget)
- RemoveRepo returns 204 with no body
- HTTP server has ReadHeaderTimeout, ReadTimeout, WriteTimeout, IdleTimeout set
- Graceful shutdown calls srv.Shutdown with 10s timeout
- All project tests pass, binary compiles
</success_criteria>

<output>
After completion, create `.planning/phases/03-core-api/03-02-SUMMARY.md`
</output>
