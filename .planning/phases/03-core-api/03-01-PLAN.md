---
phase: 03-core-api
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/domain/model/pullrequest.go
  - internal/domain/port/driven/prstore.go
  - internal/adapter/driven/sqlite/migrations/000002_add_needs_review.up.sql
  - internal/adapter/driven/sqlite/migrations/000002_add_needs_review.down.sql
  - internal/adapter/driven/sqlite/prrepo.go
  - internal/adapter/driven/sqlite/prrepo_test.go
  - internal/application/pollservice.go
autonomous: true

must_haves:
  truths:
    - "PRs where user's review is requested are persisted with needs_review=true"
    - "PRs authored by user are persisted with needs_review=false"
    - "ListNeedingReview returns only PRs with needs_review=true"
    - "Database migration adds needs_review column with default false"
  artifacts:
    - path: "internal/domain/model/pullrequest.go"
      provides: "NeedsReview boolean field on PullRequest struct"
      contains: "NeedsReview"
    - path: "internal/domain/port/driven/prstore.go"
      provides: "ListNeedingReview method on PRStore interface"
      contains: "ListNeedingReview"
    - path: "internal/adapter/driven/sqlite/migrations/000002_add_needs_review.up.sql"
      provides: "Schema migration adding needs_review column"
      contains: "needs_review"
    - path: "internal/adapter/driven/sqlite/prrepo.go"
      provides: "ListNeedingReview implementation + needs_review in Upsert/scan"
      contains: "ListNeedingReview"
    - path: "internal/application/pollservice.go"
      provides: "Sets NeedsReview during poll based on IsReviewRequestedFrom"
      contains: "NeedsReview"
  key_links:
    - from: "internal/application/pollservice.go"
      to: "internal/domain/model/pullrequest.go"
      via: "pr.NeedsReview = isReviewRequested"
      pattern: "NeedsReview.*=.*isReviewRequested"
    - from: "internal/adapter/driven/sqlite/prrepo.go"
      to: "internal/domain/port/driven/prstore.go"
      via: "implements ListNeedingReview"
      pattern: "func.*PRRepo.*ListNeedingReview"
---

<objective>
Add a persisted `needs_review` boolean to PullRequest so the HTTP API (Plan 02) can serve the "needs attention" endpoint from database queries rather than transient in-memory state.

Purpose: The Phase 3 "needs attention" endpoint (API-03) requires filtering PRs that need the user's review. Currently, `IsReviewRequestedFrom` is evaluated during polling but the result is not persisted. This plan adds persistence so the attention endpoint can query the database directly.

Output: Updated domain model, port interface, SQLite migration, updated adapter, and updated poll service -- all with passing tests.
</objective>

<execution_context>
@C:\Users\EFisher\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\EFisher\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-core-api/03-RESEARCH.md

@internal/domain/model/pullrequest.go
@internal/domain/port/driven/prstore.go
@internal/adapter/driven/sqlite/prrepo.go
@internal/adapter/driven/sqlite/prrepo_test.go
@internal/adapter/driven/sqlite/migrations/000001_initial_schema.up.sql
@internal/application/pollservice.go
@internal/application/pollservice_test.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add needs_review to domain model, port interface, and SQLite migration</name>
  <files>
    internal/domain/model/pullrequest.go
    internal/domain/port/driven/prstore.go
    internal/adapter/driven/sqlite/migrations/000002_add_needs_review.up.sql
    internal/adapter/driven/sqlite/migrations/000002_add_needs_review.down.sql
  </files>
  <action>
    1. In `internal/domain/model/pullrequest.go`, add a `NeedsReview bool` field to the PullRequest struct. Place it after `BaseBranch` and before `Labels`, in the persisted fields section (NOT in the transient fields section). This field IS persisted to SQLite.

    2. In `internal/domain/port/driven/prstore.go`, add a `ListNeedingReview(ctx context.Context) ([]model.PullRequest, error)` method to the PRStore interface. This returns all PRs where needs_review is true, ordered by updated_at descending (same ordering as ListAll).

    3. Create `internal/adapter/driven/sqlite/migrations/000002_add_needs_review.up.sql`:
       ```sql
       ALTER TABLE pull_requests ADD COLUMN needs_review INTEGER NOT NULL DEFAULT 0;
       CREATE INDEX idx_pull_requests_needs_review ON pull_requests(needs_review);
       ```

    4. Create `internal/adapter/driven/sqlite/migrations/000002_add_needs_review.down.sql`:
       ```sql
       DROP INDEX IF EXISTS idx_pull_requests_needs_review;
       ALTER TABLE pull_requests DROP COLUMN needs_review;
       ```
  </action>
  <verify>Project compiles: `go build ./...` (will fail until prrepo.go is updated in Task 2, but model and port changes should parse correctly)</verify>
  <done>PullRequest has NeedsReview field, PRStore has ListNeedingReview method, migration files exist</done>
</task>

<task type="auto">
  <name>Task 2: Update SQLite adapter and poll service to persist needs_review</name>
  <files>
    internal/adapter/driven/sqlite/prrepo.go
    internal/adapter/driven/sqlite/prrepo_test.go
    internal/application/pollservice.go
  </files>
  <action>
    1. In `internal/adapter/driven/sqlite/prrepo.go`:

       a. Update the `Upsert` method: Add `needs_review` to both the INSERT column list and the ON CONFLICT UPDATE SET clause. Convert `pr.NeedsReview` bool to int (0/1) the same way `IsDraft` is handled. Add it as a parameter in the ExecContext call.

       b. Update the `scanPR` function: Add `needsReview int` variable, scan it after `isDraft`, and set `pr.NeedsReview = needsReview != 0`.

       c. Update ALL query constants that have SELECT column lists (in `GetByRepository`, `GetByStatus`, `GetByNumber`, `ListAll`) to include `needs_review` after `is_draft`. The scan order in scanPR must match. The column order in SELECT must be:
          `id, number, repo_full_name, title, author, status, is_draft, needs_review, url, branch, base_branch, labels, opened_at, updated_at, last_activity_at`

       d. Add the `ListNeedingReview` method:
          ```go
          func (r *PRRepo) ListNeedingReview(ctx context.Context) ([]model.PullRequest, error) {
              const query = `
                  SELECT id, number, repo_full_name, title, author, status, is_draft, needs_review,
                         url, branch, base_branch, labels, opened_at, updated_at, last_activity_at
                  FROM pull_requests
                  WHERE needs_review = 1
                  ORDER BY updated_at DESC
              `
              return r.queryPRs(ctx, query)
          }
          ```

    2. In `internal/adapter/driven/sqlite/prrepo_test.go`:
       Add a test for `ListNeedingReview` that:
       - Upserts two PRs: one with NeedsReview=true, one with NeedsReview=false
       - Calls ListNeedingReview
       - Asserts only the NeedsReview=true PR is returned
       - Follow the existing test patterns (use testDB helper, testify assertions)

    3. In `internal/application/pollservice.go`:
       In the `pollRepo` method, after the `isReviewRequested` check (around line 183), set `pr.NeedsReview = isReviewRequested` on the PR before it is upserted. This ensures that:
       - PRs where the user is requested as reviewer get `needs_review = true`
       - PRs authored by the user (but not review-requested) get `needs_review = false`
       - The field is set regardless of whether the PR was skipped for unchanged UpdatedAt, because the relevant line is BEFORE the unchanged check. Actually, looking more carefully: the `isReviewRequested` variable is computed at line 183, the unchanged skip is at lines 191-194, and `Upsert` is at line 198. So `pr.NeedsReview` must be set BEFORE the unchanged skip would apply. Set it right after the relevance check (after line 189, before line 191):
         ```go
         pr.NeedsReview = isReviewRequested
         ```
       This way, even if UpdatedAt hasn't changed, the needs_review field gets set correctly on the model. However, the unchanged skip at line 191 will prevent re-upsert. This is fine because needs_review is determined from transient fields that are re-populated on every fetch. If the PR was previously upserted with the correct value, skipping is correct. BUT: if the user was NEWLY added as a reviewer and the PR's UpdatedAt didn't change (unlikely but possible), the skip would miss the update. To handle this edge case, modify the unchanged check to also compare NeedsReview:
         ```go
         if stored, ok := storedByNumber[pr.Number]; ok {
             if stored.UpdatedAt.Equal(pr.UpdatedAt) && stored.NeedsReview == pr.NeedsReview {
                 skippedUnchanged++
                 continue
             }
         }
         ```
       Wait -- `stored` comes from the database and already has NeedsReview populated (since we updated scanPR). This comparison works correctly.
  </action>
  <verify>
    Run: `go test ./internal/adapter/driven/sqlite/... -v -run TestListNeedingReview` -- new test passes.
    Run: `go test ./internal/... -v` -- all existing tests still pass.
    Run: `go build ./...` -- project compiles.
  </verify>
  <done>
    - Upsert persists needs_review to SQLite
    - scanPR reads needs_review from database
    - ListNeedingReview returns only PRs with needs_review=true
    - Poll service sets NeedsReview based on IsReviewRequestedFrom result
    - All tests pass including new ListNeedingReview test
  </done>
</task>

</tasks>

<verification>
1. `go build ./...` compiles without errors
2. `go test ./internal/... -v` -- all tests pass (existing + new)
3. Migration file exists and has correct SQL syntax
4. `grep -r "NeedsReview" internal/` shows field in model, port, adapter, and pollservice
</verification>

<success_criteria>
- PullRequest model has NeedsReview bool field (persisted, not transient)
- PRStore interface has ListNeedingReview method
- SQLite migration adds needs_review column with index
- PRRepo implements ListNeedingReview with WHERE needs_review = 1
- Poll service sets NeedsReview = true for review-requested PRs, false otherwise
- All existing tests pass, new ListNeedingReview test passes
</success_criteria>

<output>
After completion, create `.planning/phases/03-core-api/03-01-SUMMARY.md`
</output>
